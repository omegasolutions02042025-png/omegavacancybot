import google.generativeai as genai
import asyncio
import json
import re
from datetime import datetime
import os
from dotenv import load_dotenv

load_dotenv()


GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')

genai.configure(api_key=GEMINI_API_KEY)


async def process_vacancy_with_gemini(text: str) -> dict | None:
    """
    Анализирует текст вакансии с помощью Gemini API, выполняет фильтрацию,
    очистку и извлечение данных в один шаг.

    Args:
        text: Строка с полным текстом вакансии.

    Returns:
        Словарь (dict) с извлеченными данными в формате JSON
        или None, если вакансия была отфильтрована.
    """
    print("🚀 Запускаем обработку вакансии через Gemini...")

    # Текущая дата для prompt
    current_date = datetime.now().strftime("%d.%m.%Y")
    current_time = datetime.now().strftime("%H:%M")
    current_tz = "+03:00"  # МСК по умолчанию

    # --- ЕДИНЫЙ ПРОМПТ ДЛЯ GEMINI ---
    system_prompt = f"""
    Ты — фильтр вакансий. На вход приходит ТЕКСТ ВАКАНСИИ. Работай строго по правилам ниже.
При противоречиях выбирай ОТСЕЧЬ. Логика между разделами — И (AND).
Сегодня: {current_date} {current_time} ({current_tz}).

ЦЕЛЬ:
1) Решить, отсекать вакансию или нет (если отсечь — вернуть структуру с полями = None).
2) Если НЕ отсекать — очистить и нормализовать текст, извлечь поля и вернуть словарь строго заданного формата.

ГЛОБАЛЬНОЕ ПРАВИЛО СОХРАНЕНИЯ СТРУКТУРЫ (ВАЖНО):
— По всему тексту вакансии СТРОГО СОХРАНЯЙ исходную структуру: порядок строк и абзацев, пустые строки,
  маркеры списков (-, •, —), нумерацию (1), 1., 1), тире/кавычки, эмодзи и спецсимволы, регистр,
  последовательности пробелов/табов. Ничего не переформатируй и не «склеивай».
  Разрешено удалять/перемещать ТОЛЬКО явно указанные ниже фрагменты (оплата/контакты/заголовки «плюсов»/🆔 и т.п.).
  Все прочие символы и переносы должны остаться без изменений.

НОРМАЛИЗАЦИИ:
- РБ ≡ Беларусь ≡ Belarus ≡ BY ≡ Белоруссия ≡ Belorussia; РФ ≡ Россия ≡ Russian Federation ≡ Russia ≡ RU.
- Города РБ: Минск, Брест, Витебск, Гомель, Гродно, Могилёв (любые падежи).
- «Дружественные страны» / friendly/allied countries / CIS/СНГ / EAEU/ЕАЭС — считай, что включают Беларусь (РБ).
- Отсутствие ограничений: «любой/любая/any», «без разницы», «всё равно», «не имеет значения»,
  «no restriction», «remote/удалённо/удаленка/удалёнка», «любой регион/страна», а также ПОЛНОЕ ОТСУТСТВИЕ
  упоминаний локации/гражданства — трактуй как допускающие Беларусь, если нет РФ-ограничителей.
  Исключение: конструкции, привязанные к РФ («любой регион РФ», «работа из любой точки РФ», «оформление в РФ») — это РФ-ограничители.
- Перечисления стран (разделители «/», «,», «и», «or»), напр. «РБ/РФ», «РБ и РФ», «РФ, РБ» — трактуй как ДОПУСК обеих; это НЕ ограничитель РФ.
- Тайм-зоны: МСК/MSK = UTC+3. Если TZ не указана, используй {current_tz}.
- Нормализация длительности: «3х/3-х/3 x» трактуй как «3».

БЛОК A. СРОКИ ПРОЕКТА (ПРОДОЛЖИТЕЛЬНОСТЬ И ДЕДЛАЙН)
A1. ПРОДОЛЖИТЕЛЬНОСТЬ (< 3 месяцев → ОТСЕЧЬ):
  A1.1. ОТСЕЧЬ, если явно < 3 мес: 1/2 мес;
  A1.2. Конструкции с нижней границей < 3 (например, «от 2 мес») ВСЕГДА считаются < 3 и ведут к отсекаю,
        даже если эта фраза стоит после шапки/подсказки в скобках (например: «Продолжительность проекта (от 2х месяцев): от 2 мес»).
        Оценивай именно фактическое значение после «:», а текст подсказки игнорируй.
        К «допускающим < 3» также относятся: «от 3-х мес», «от 3х месяцев», варианты с плюсом («от 3 мес+», «от 3 месяцев +», «от 3х месяцев+»),
        «3+ мес», «3–6 мес», «более 3 мес», «до 4 мес», «≈3–4 мес».
  A1.3. НЕ отсекать, если гарантировано ≥ 3 мес: «3 мес», «от 3 мес», «3–6 мес», «≥ 3 мес», «6+ мес»,
        «полгода», «2 квартала», «12 мес», «год», «long-term».
  A1.4. Если длительность НЕ указана — A1 не применяется.
  A1.5. ШАПКА БЕЗ ЗНАЧЕНИЯ — НЕ ОТСЕКАТЬ: если есть только заголовок/лейбл длительности (строка оканчивается «:»)
        и после него НЕТ значения ни в этой строке, ни в непосредственной следующей строке. Если после «:» есть «от 3 мес» — применяй A1.2 и отсекать.
  A1.6. Нормализация: трактуй «3х/3-х/3 x» как «3».

A2. ДЕДЛАЙН (в прошлом или истёк к текущему моменту → ОТСЕЧЬ):
  A2.1. Распознавай даты/время/TZ: DD.MM.YYYY, DD.MM.YY, DD/MM/YYYY, YYYY-MM-DD, «30 сентября 2025», «до 30.09»,
        а также «сегодня», «завтра», «до конца дня» (EOD/COB), EOW/EOM, «до пятницы», «до 18:00 МСК», «до 23:59», «до 15:00 UTC+3».
  A2.2. Если указан часовой пояс (МСК/MSK/UTC±X) — используй его, иначе {current_tz}.
  A2.3. Если год не указан — используй текущий год. Если «до [месяц]» без дня — дедлайн = последний день месяца 23:59 (в соответствующей TZ).
  A2.4. Отсекай, если:
        • дедлайн < текущего момента; ИЛИ
        • дедлайн = сегодня и время НЕ указано; ИЛИ
        • дедлайн = сегодня и указано время ≤ текущего времени.
        (Если дедлайн сегодня и время > текущего — НЕ отсекать.)
  A2.5. ШАПКА БЕЗ ЗНАЧЕНИЯ — НЕ ОТСЕКАТЬ: если есть только заголовок/лейбл дедлайна (строка оканчивается «:»)
        и нет даты/времени ни в этой строке, ни в непосредственной следующей строке — A2 не применяется.
  A2.6. «ASAP/как можно скорее» — это не дедлайн (A2 не применяется).
  A2.7. Если дедлайн не найден — A2 не применяется.

ДВОЙНОЙ СТОП-КОНТРОЛЬ РФ (2 слоя защиты):
1) «Прямое указание без альтернатив». Если в строке с локацией/гражданством указано
   «РФ/Россия/RF/Russia» и ни в этой, ни в непосредственной следующей строке нет альтернатив
   (РБ/Belarus/BY/remote/any/no restriction/friendly countries/CIS/СНГ/EAEU/ЕАЭС),
   это считается ограничителем РФ → ОТСЕЧЬ.
2) «Явные РФ-ограничители». Любые формулировки: «только РФ», «из РФ», «на территории РФ», «жители РФ»,
   «работа из любой точки РФ», «любой регион РФ», «лок: РФ», «оформление в РФ», «нахождение в РФ обязательно»,
   «только гражданство РФ», «паспорт РФ обязателен», «налоговое резидентство РФ обязательно»,
   «только граждане РФ», «только россияне» → ОТСЕЧЬ.

БЛОК B. ОБЩИЕ КРИТЕРИИ ОТСЕВА (любой пункт → ОТСЕЧЬ):
B1. ЛОКАЦИЯ: отсекай, если выполнен любой из слоёв «ДВОЙНОГО СТОП-КОНТРОЛЯ РФ» для локации.
B2. ГРАЖДАНСТВО: отсекай, если выполнен любой из слоёв «ДВОЙНОГО СТОП-КОНТРОЛЯ РФ» для гражданства.

    
B4. Запрет на подачу: «стоп»/«STOP»/«❌ стоп» и подобные.

БЛОК C. КРИТЕРИИ ПРОХОЖДЕНИЯ (ДОЛЖНЫ быть истинны одновременно; иначе — ОТСЕЧЬ):
C1. ЛОКАЦИЯ: допускается РБ/Беларусь, ИЛИ указаны «дружественные страны»/CIS/СНГ/EAEU/ЕАЭС/friendly countries,
    ИЛИ «удалённо/any/no restriction/любая/без разницы/всё равно/не имеет значения»,
    ИЛИ про локацию НИЧЕГО НЕ СКАЗАНО — и при этом НЕТ РФ-ограничителей и НЕ сработал слой (1).
    Перечисления «РБ/РФ», «РБ и РФ», «РФ, РБ» — проходят (если нет РФ-ограничителей).
    Если указана ровно одна страна из пары (например, «Локация: РФ») без альтернатив — C1 НЕ выполнено.
C2. ГРАЖДАНСТВО: допускается гражданство РБ, ИЛИ «дружественные страны»/CIS/СНГ/EAEU/ЕАЭС/friendly countries,
    ИЛИ «любое/any/no restriction/без ограничений/без разницы/всё равно/не имеет значения»,
    ИЛИ про гражданство НИЧЕГО НЕ СКАЗАНО — и при этом НЕТ РФ-ограничителей и НЕ сработал слой (1).
    Если указано ровно «Гражданство: РФ» без альтернатив — C2 НЕ выполнено.

ЕСЛИ выполнено хотя бы одно условие отсева из блоков A или B, ИЛИ не выполнены C1/C2,
— верни структуру с полями = None (см. «ФОРМАТ ОТВЕТА»). Иначе — продолжай обработку.

ОБРАБОТКА ТЕКСТА (выполняй последовательно; применяется ТОЛЬКО если вакансия НЕ отсечена):
A) УДАЛЕНИЕ УПОМИНАНИЙ ОПЛАТЫ: полностью удали любые условия оплаты/актирования/сроки оплаты/отсрочки.
B) ЕДИНИЦА КОНТАКТА: любые варианты «Вопросы и предложения … @username … Указать 🆔 запроса.»
   ЗАМЕНИ на: «Вопросы и предложения пишите Дмитрию ➡️@Dimitryver. Указать 🆔 запроса.»
   (распознавай произвольные формулировки и любые @имена).
C) УДАЛЕНИЕ КОНТАКТОВ: удали email (включая обфускации «name[at]domain dot com»), телефоны/WhatsApp/Telegram/ссылки
   (http/https, t.me, @username), юзернеймы, короткие ссылки. Остальное — не трогай.
D) ЗАГОЛОВОК ВАКАНСИИ: если в начале есть заголовок (например: «🥇 Java разработчик c Camunda»),
   УДАЛИ его из текста и верни в "vacancy_title" (без эмодзи и лишних пробелов); остальной текст не меняй.
E) ИДЕНТИФИКАТОР: найди ПЕРВЫЙ идентификатор:
   • «🆔 XX-1234» (XX — латинские заглавные, 1234 — цифры) ИЛИ
   • «🆔 8581» (только цифры).
   УДАЛИ его из текста и верни "vacancy_id" (без символа 🆔). Если нет — None.
F) СТАВКА ("rate"): найди числовую ставку/ставку закупки. Если указаны две — для РФ и для не РФ — возьми ставку для НЕ РФ.
   Если единственная — верни её. Верни ТОЛЬКО число (без валют/«от»/«~»/«/»/пробелов/тыс/млн).
   Диапазон «от N до M» → возьми M; «до: N» → возьми N; «≈N» → возьми N. Не конвертируй периодичность (в час/день/месяц).
   Если ставки нет («смотрим вашу» и т.п.) — "rate": 0. Исходные упоминания ставки УДАЛИ.
G) ТРЕБОВАНИЯ (объединение «плюсов» с основными):
   G1. Основной список — разделы «Требования», «Основные требования», «Обязательные требования»,
       англ.: «Requirements», «Required», «Must have». Если их нет, но есть «плюсы» — создай раздел «Требования»
       и помести его на место первого найденного блока требований/«плюсов».
   G2. Что считать «плюсами» (без учета регистра/пунктуации; кавычки/маркеры НЕ обязательны):
       — Заголовки/подзаголовки/фразы: «будет плюсом», «будет большим плюсом», «будет преимуществом»,
         «большим преимуществом будет», «плюсом», «плюсом будет», «как плюс»,
         «желательно», «предпочтительно», «не обязательно, но желательно», «опционально», «Доп. требования:»;
         англ.: «nice to have», «good to have», «would be a plus», «big/strong plus», «preferred»,
         «optional», «bonus», «as an advantage», «advantageous».
       — Фразы-связки с «если»: распознавай конструкции «будет плюсом(,|—|-|:)?\s*если …»
         (в т.ч. «Будет плюсом если вы …») — с любыми знаками препинания или без — и относись к ним как к «плюсам».
       — Эти фразы могут встречаться в заголовке раздела, внутри пункта, в начале/конце предложения,
         в скобках («…(будет плюсом)»), с эмодзи/символами (напр. «➕», «+», «🌟», «⭐») или без них — во всех случаях
         считай такой пункт «плюсом».
   G3. Что НЕ считать «плюсами»: разделы про условия/бонусы/преимущества работодателя
       («Преимущества», «Бонусы», «Мы предлагаем», «Benefits», «Perks», «Conditions», «Условия»), а также
       «Задачи/Обязанности/Responsibilities/What you will do».
   G4. Как объединять:
       — Вырежи ТОЛЬКО заголовки «плюсов»/вводные слова, сами пункты оставь как есть.
       — Если «плюсы» перечислены одной строкой через запятые — перенеси строку целиком как один пункт,
         не меняя пунктуации.
       — Если пометка «(будет плюсом/optional/…)» стоит в конце пункта, перенеси пункт в конец списка
         требований и УДАЛИ только скобочную пометку.
       — Порядок: 1) исходные обязательные пункты (как были), 2) затем все «плюсы» в порядке появления сверху вниз.
       — Дубли: убери точные дубликаты (trim + без финальной точки/«;»). Семантические различия — не объединяй.
H) ДЕДЛАЙН (извлечение значений, НЕ отсев здесь): определи дедлайн (дату/время) по правилам A2.
   Верни "deadline_date" = "DD.MM.YYYY" или None; "deadline_time" = "HH:MM" или None.
I) СТРУКТУРА (напоминание): после всех манипуляций глобально соблюдай правило сохранения структуры текста
   (см. блок «ГЛОБАЛЬНОЕ ПРАВИЛО СОХРАНЕНИЯ СТРУКТУРЫ»).
K) Если встречаются фразы/эквиваленты (любой регистр/язык):
    «акты поквартально», «квартальное актирование», «поквартальная оплата», «актирование», «ежеквартально»,
    «quarterly invoicing/billing», «net 60», «net 90», «N60», «N90», «deferred payment», «post-payment».
    Верни "acts" = true. В противном случае — false.

L) Если в тексте указана длительность проекта менее 6 месяцев (например: "3 месяца", "4 мес.", "полгода", "до 5 месяцев", "3 мес+"), то возвращай short_project: true.
    Если указано "от N месяцев", то это нижняя граница, а не ограничение сверху. В этом случае не считай проект коротким, даже если N < 6.
    Если указано "от N до M месяцев", смотри на верхнюю границу: если M < 6, то short_project: true, иначе false.
    Если указано "до конца года", "с возможностью продления", или другая формулировка, явно предполагающая срок ≥ 6 месяцев, то short_project: false.
    В остальных случаях — short_project: false.

M) Если встречаются фразы вида:

    - "Отсрочка платежа ..."
    - "Отсрочка ..."
    - "Условия оплаты: отсрочка ..."
то верни содержимое после слова "отсрочка" в переменной delay_payment, удаляя само слово и лишние пробелы. Иначе — delay_payment: null.

N) Если в отсрочка платежа больше 35 рабочих дней или 50 календарных дней, верни long_payment: true, иначе — long_payment: false.


O) Если в тексте встречаются фразы:
              - "Только штатные кандидаты"
              - "Рассматриваем только штатных кандидатов"
              - "Оформление только штат компании"
            то верни only_fulltime: true, иначе — only_fulltime: false.

ФОРМАТ ОТВЕТА — СТРОГО СЛОВАРЬ:
{{
  "text": "<очищенный текст вакансии>" или null (если отсечена),
  "rate": <целое число или 0> или null,
  "deadline_date": "DD.MM.YYYY" или null,
  "deadline_time": "HH:MM" или null,
  "vacancy_id": "<id или null>",
  "vacancy_title": "<заголовок или null>",
  "acts": true или false,
  "short_project": true или false
  "delay_payment": "<содержимое фразы или null>",
  "only_fulltime": true или false,
  "long_payment": true или false
}}
Никаких других слов/символов не добавляй. Не используй Markdown/код-блоки в ответе.
"""

    # Модель Gemini
    model = genai.GenerativeModel('gemini-2.5-flash')
    generation_config = genai.types.GenerationConfig(temperature=0.1)
    
    full_prompt = system_prompt + "\n\nТекст вакансии:\n\n" + text

    try:
        response = await model.generate_content_async(
            full_prompt,
            generation_config=generation_config
        )

        clean_text = response.text.strip()
        print("✅ Ответ от Gemini получен.")
        print(clean_text)

        # Проверка на отсечение вакансии
        if clean_text.lower() == 'null':
            print("❌ Вакансия отфильтрована.")
            return None

        # Попытка извлечения JSON
        json_match = re.search(r'\{.*\}', clean_text, re.DOTALL)
        if json_match:
            try:
                return json.loads(json_match.group(0))
            except json.JSONDecodeError as e:
                print(f"Ошибка парсинга JSON: {e}")
                return None
        else:
            print("JSON не найден в ответе модели.")
            return None

    except Exception as e:
        print(f"Ошибка при вызове Gemini API: {e}")
        return None



async def format_vacancy_gemini(text: str, vacancy_id: str, date: str | None = None) -> str:
    """
    Функция для структурированного оформления вакансии с помощью Gemini API.
    Возвращает готовый текст в нужном формате.
    """
    if date is None:
        date = datetime.now().strftime("%d.%m.%Y")
        
    print(f"[*] Форматируем вакансию ID: {vacancy_id} от {date}...")
    
    # Промпт для Gemini, объединяющий системную и пользовательскую роли
    prompt = f"""
Ты — редактор вакансий.
На вход ты получаешь текст вакансии. Твоя задача — оформить его в структурированном виде для публикации, строго соблюдая формат.

⚡️ ВАЖНО:
— Никогда не удаляй и не изменяй HTML-тэги (<s>, <b>, <i> и любые другие).
— Особенно не трогай тэги вокруг следующих строк:
  * «ИП: ...»
  * «Самозанятый: ...»
  * «- Ежемесячная выплата Штат/Контракт»
— Эти элементы должны оставаться с тэгами в исходном виде.

⚡️ Правила форматирования:
— В названии должности всегда указывать грейд (Junior / Middle / Senior / Lead), если он есть.
— Раздел «Будет плюсом» включается в общий список «💻 Требования» (без отдельного блока).
— Каждый пункт требований — отдельной строкой с маркером.
— Между разделами и блоками вакансии должна быть ровно 1 пустая строка.
— В тексте вакансии не должно быть 2 и более пустых строк подряд.
— Не удаляй и не сокращай информацию, используй все данные из текста.
— Блок «⚠️ Особые условия» включай только если в тексте реально есть данные (NDA, кол-во этапов интервью, оформление и т.д.).

⚡️ Структура итогового текста:

🆔{vacancy_id}
📅 Дата публикации: {date}

🥇 [Название должности] ([Грейд])

💰 Месячная ставка (на руки) до:
- Ежемесячная выплата Штат/Контракт: [сумма] RUB
- С отсрочкой платежа "[срок, например: 35 рабочих дней]" после подписания акта ([Актирование ежемесячно/поквартальное]):
  ИП: [сумма] RUB,
  Самозанятый: [сумма] RUB

📍 Локация/Гражданство: [страны, города]
🏠 Формат работы: [удалённо / офис / гибрид]
🎓 Грейд: [Junior / Middle / Senior / Lead]
📆 Срок проекта: [сроки]
🚀 Старт проекта: [ASAP или дата]

📌 О проекте:
[Краткое описание проекта]

📎 Задачи:
— [Перечислить задачи из вакансии]

💻 Требования:
— [Обязательное требование 1]
— [Обязательное требование 2]
— [Будет плюсом 1]
— [Будет плюсом 2]

⚠️ Особые условия:
— [NDA, кол-во этапов интервью, трудоустройство и т.д.]

❗️ Обязательные данные по кандидату при подаче:
● ФИО
● Страна + Город
● Дата рождения (не возраст, а дата)
● Электронная почта
● Образование (ВУЗ, год окончания, специальность)
● Грейд
● Ставка
● Чек-лист соответствия требованиям (ДА/НЕТ)

Контакт для вопросов: [имя + @Telegram]

---
Вот текст вакансии для обработки:

{text}
"""
    
    model = genai.GenerativeModel('gemini-2.5-flash')
    generation_config = genai.types.GenerationConfig(temperature=0.1)
    
    try:
        response = await model.generate_content_async(prompt, generation_config=generation_config)
        return response.text.strip()
    except Exception as e:
        print(f"🔥 Ошибка при форматировании вакансии: {e}")
        return False


async def generate_hashtags_gemini(vacancy_text: str) -> str:
    """
    Генерирует хэштеги из текста вакансии с помощью Gemini API.
    """
    print("[*] Генерируем хэштеги...")
    
    prompt = f"""
Вот текст вакансии:

{vacancy_text}

Сформируй список хэштегов в одну строку через пробел.

Правила:
1. По технологиям/стеку (например: #Java #Spring #PostgreSQL #Docker) — извлеки их из описания.
2. По грейду: #Junior или #Middle или #Senior — определи из текста.
3. По отрасли (например: #Fintech #Retail #Banking) — определи по контексту.

Выведи только строку с хэштегами.
"""
    
    model = genai.GenerativeModel('gemini-2.5-flash')
    generation_config = genai.types.GenerationConfig(temperature=0.1)
    
    try:
        response = await model.generate_content_async(prompt, generation_config=generation_config)
        return response.text.strip()
    except Exception as e:
        print(f"🔥 Ошибка при генерации хэштегов: {e}")
        return False



# --- ПРИМЕР ИСПОЛЬЗОВАНИЯ ---
async def main():
    # Пример текста вакансии для тестирования
    sample_vacancy_text = """
🆔 BD-8744
🆔QA-8486

🥇 AQA Team Lead

О кандидате:
Стек: Python (PyTest, Selenium, Requests, Netmiko)
Linux (Ubuntu, Astra, Debian, Centos)
Грейд: 1 Team Lead
Опыт в годах:от 3
Локация специалиста: РФ, РБ
Тайм-зона проекта: Мск +- 2 часа
Гражданство: РФ, РБ

О проекте:
Описание проекта: проект межсетевой экран Аргос FW - высокопроизводительное отечественное решение для фильтрации трафика в ЦОД, в корпоративной сети, работающее на скоростях более 100 Гбит/c для EMIX профиля
Название конечного клиента или отрасль: проект межсетевой экран Аргос FW
Дата старта проекта: ASAP
Продолжительность проекта (от 3х месяцев):долгосрок

Оформление:
Тип занятости: удалёнка 
Ставка закупки: ваши предложения 
Загрузка: фулл-тайм 
Условия оплаты: отсрочка 35 рабочих дней 
Особые условия: -


Вопросы и предложения ➡️@IamKate013 или в общий чат.
Указать 🆔 запроса. 

📝Присылать СV + данные по кандидату: 
● ФИО
● Страна + Город
● Грейд
● Ставка
● Оценить требования ДА/НЕТ, в соответствии с наличием опыта.️

📌 Задачи:
Функциональное/нефункциональное тестирование;
Развитие тестового фреймворка, автоматизация тестовых сценариев на python + pytest;
Глубокое погружение в теорию компьютерных сетей;
Настройка и поддержка тестового окружения, развитие процессов CI/CD;
Документирование результатов тестирования: занесение дефектов в багтрекинговую систему;
Ревью и анализ требований, тест-дизайн и создание тестовых сценариев;
Регулярная коммуникация со смежными командами: разработка, проектный офис.

💻 Требования: 

Python (PyTest, Selenium, Requests, Netmiko)
Linux (Ubuntu, Astra, Debian, Centos)
TMS (Allure TestOps)
OSI/ISO (wireshark, tcpdump)
SQL (PostgreSQL, Clickhouse)
GIT
RESTful API (Postman, Swagger)
Docker.

➕ Будет плюсом: 
Опыт работы с Gitlab CI;
Опыт работы с Ansible;
опыт работы с телекоммуникационным оборудованием (коммутаторы, маршрутизаторы и т.д.).
    """
    
    # Вызов основной функции
    result = await process_vacancy_with_gemini(sample_vacancy_text)
    
    # Красивый вывод результата
    if result:
        print("\n--- ИТОГОВЫЙ РЕЗУЛЬТАТ ---")
        print(json.dumps(result, indent=2, ensure_ascii=False))
    else:
        print("\n--- ОБРАБОТКА ЗАВЕРШЕНА ---")
        print(json.dumps(result, indent=2, ensure_ascii=False))


if __name__ == "__main__":
    # Запуск асинхронной функции
    asyncio.run(main())