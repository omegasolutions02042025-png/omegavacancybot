import google.generativeai as genai
import asyncio
import json
import re
from datetime import datetime
import os
from dotenv import load_dotenv

load_dotenv()

GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
genai.configure(api_key=GEMINI_API_KEY)


async def process_vacancy_with_gemini(text: str) -> dict | None:
    """
    Анализирует текст вакансии с помощью Gemini API, выполняет фильтрацию,
    очистку и извлечение данных в один шаг.

    Args:
        text: Строка с полным текстом вакансии.

    Returns:
        Словарь (dict) с извлеченными данными в формате JSON
        или None, если вакансия была отфильтрована.
    """
    print("🚀 Запускаем обработку вакансии через Gemini...")

    # Текущая дата для prompt
    current_date = datetime.now().strftime("%d.%m.%Y")
    current_time = datetime.now().strftime("%H:%M")
    current_tz = "+03:00"  # МСК по умолчанию

    # --- ЕДИНЫЙ ПРОМПТ ДЛЯ GEMINI ---
    system_prompt = f"""
    Ты — фильтр вакансий. На вход приходит ТЕКСТ ВАКАНСИИ. Работай строго по правилам ниже.
При противоречиях выбирай ОТСЕЧЬ. Логика между разделами — И (AND).
Сегодня: {current_date} {current_time} ({current_tz}).

ЦЕЛЬ:
1) Решить, отсекать вакансию или нет (если отсечь — вернуть структуру с полями = null и в переменной "reason" указать причину).
2) Если НЕ отсекать — очистить и нормализовать текст, извлечь поля и вернуть словарь строго заданного формата.

ГЛОБАЛЬНОЕ ПРАВИЛО СОХРАНЕНИЯ СТРУКТУРЫ (ВАЖНО):
— По всему тексту вакансии СТРОГО СОХРАНЯЙ исходную структуру: порядок строк и абзацев, пустые строки,
  маркеры списков (-, •, —), нумерацию (1), 1., 1), тире/кавычки, эмодзи и спецсимволы, регистр,
  последовательности пробелов/табов. Ничего не переформатируй и не «склеивай».
  Разрешено удалять/перемещать ТОЛЬКО явно указанные ниже фрагменты (оплата/контакты/заголовки «плюсов»/🆔 и т.п.).
  Все прочие символы и переносы должны остаться без изменений.

НОРМАЛИЗАЦИИ:
НОРМАЛИЗАЦИИ:
- Определи страну/локацию по ключевым словам.
- Если в тексте встречаются слова «РФ», «Россия», «Moscow», «Москва», «Санкт-Петербург», «Казань», «Новосибирск» и т.п. — добавь "РФ" в список location.
- Если встречаются слова «Беларусь», «BY», «Минск», «Гродно», «Брест», «Витебск», «Гомель», «Могилёв», «дружественные страны», «СНГ», «CIS», «EAEU», «Eurasian», «Kazakhstan», «Казахстан», «Kyrgyzstan», «Киргизия», «Armenia», «Армения», «Azerbaijan», «Азербайджан» — добавь "РБ" в список location.
РБ-группа/«дружественные/СНГ/EAEU/CIS/Eurasian/Kazakhstan/Казахстан/Kyrgyzstan/Кыргызстан/Armenia/Армения/Azerbaijan/Азербайджан» если есть такие фразы или похожие то добавь "РБ" в список location.
- Если указано «удалённо», «remote», «any location», «гибрид», «работа из любой точки», добавь обе ("РФ" и "РБ") в список location.
- Если указаны обе группы (РФ и РБ/СНГ) — добавь обе страны: ["РФ", "РБ"].
- Если указано несколько локаций — возвращай список (например ["РФ", "РБ"]).
- Если не удаётся определить — верни пустой список [].
- Тайм-зоны: МСК/MSK = UTC+3. Если TZ не указана, используй {current_tz}.
- Нормализация длительности: «3х/3-х/3 x» трактуй как «3».

БЛОК A. СРОКИ ПРОЕКТА (ПРОДОЛЖИТЕЛЬНОСТЬ И ДЕДЛАЙН)
A1. ПРОДОЛЖИТЕЛЬНОСТЬ (< 3 месяцев → ОТСЕЧЬ):
— ОТСЕЧЬ, если длительность < 3 месяцев (в т.ч. «1/2 мес», «до 2 мес», «≈2–2.5 мес», «3 мес-» и т.п.).
— ОТСЕЧЬ, если длительность НЕ УКАЗАНА (есть «Продолжительность:» без значения в этой строке и в следующей).
— «от N до M»: смотри нижнюю границу для отсева (<3 → отсев). Для флага «короткий проект» смотри верхнюю границу (см. L).
— «до конца года»: если от текущей даты до конца года < 90 дней → считать < 3 месяцев → ОТСЕЧЬ.
— НЕ отсекать, если явно ≥ 3 месяцев: «3 мес», «от 3 мес», «3–6 мес», «≥3», «6+ мес», «полгода», «год», «long-term» и т.п.

A2. ДЕДЛАЙН (в прошлом или истёк к текущему моменту → ОТСЕЧЬ):
  A2.1. Распознавай даты/время/TZ: DD.MM.YYYY, DD.MM.YY, DD/MM/YYYY, YYYY-MM-DD, «30 сентября 2025», «до 30.09»,
        а также «сегодня», «завтра», «до конца дня» (EOD/COB), EOW/EOM, «до пятницы», «до 18:00 МСК», «до 23:59», «до 15:00 UTC+3».
  A2.2. Если указан часовой пояс (МСК/MSK/UTC±X) — используй его, иначе {current_tz}.
  A2.3. Если год не указан — используй текущий год. Если «до [месяц]» без дня — дедлайн = последний день месяца 23:59 (в соответствующей TZ).
  A2.4. Отсекай, если:
        • дедлайн < текущего момента; ИЛИ
        • дедлайн = сегодня и время НЕ указано; ИЛИ
        • дедлайн = сегодня и указано время ≤ текущего времени.
        (Если дедлайн сегодня и время > текущего — НЕ отсекать.)
  A2.5. ШАПКА БЕЗ ЗНАЧЕНИЯ — НЕ ОТСЕКАТЬ: если есть только заголовок/лейбл дедлайна (строка оканчивается «:»)
        и нет даты/времени ни в этой строке, ни в непосредственной следующей строке — A2 не применяется.
  A2.6. «ASAP/как можно скорее» — это не дедлайн (A2 не применяется).
  A2.7. Если дедлайн не найден — A2 не применяется.
  A2.8. Распознавай форматы: DD.MM.YYYY, DD.MM.YY, DD/MM/YYYY, YYYY-MM-DD, «30 сентября 2025», «до 30.09», «сегодня», «завтра», «до конца дня» (EOD/COB), EOW/EOM, «до пятницы», «до 18:00 МСК», «до 23:59», «до 15:00 UTC+3».
  Если год не указан — подставь текущий. Если «до [месяц]» без дня — последний день месяца 23:59 (в указанной TZ).
  «сегодня» без времени: внутренне считай 18:00 локального времени проверки. Если сейчас ≥ 18:00 — ОТСЕЧЬ, иначе — нет. В ответ время не подставляй.
  ОТСЕЧЬ, если дедлайн в прошлом; либо «сегодня» и (по правилу) уже истёк.
 «ASAP/как можно скорее» — не дедлайн (не влияет на отсев).


БЛОК B. ОБЩИЕ КРИТЕРИИ ОТСЕВА (любой пункт → ОТСЕЧЬ):
B1. Запрет на подачу: «стоп»/«STOP»/«❌ стоп» и подобные.

БЛОК С. ВЫВОД ДОПОЛНИТЕЛЬНОЙ ИНФОРМАЦИИ:
С1. Выводи причину отсева в переменной reason.
С2. Если нет локации или гражданства — верни utochnenie - true

ЕСЛИ выполнено хотя бы одно условие отсева из блоков A или B,
— верни структуру с полями = None (см. «ФОРМАТ ОТВЕТА»). Иначе — продолжай обработку.

ОБРАБОТКА ТЕКСТА (выполняй последовательно; применяется ТОЛЬКО если вакансия НЕ отсечена):
A) УДАЛЕНИЕ УПОМИНАНИЙ ОПЛАТЫ: полностью удали любые условия оплаты/актирования/сроки оплаты/отсрочки.
B) ЗАГОЛОВОК ВАКАНСИИ: если в начале есть заголовок (например: «🥇 Java разработчик c Camunda»),
   УДАЛИ его из текста и верни в "vacancy_title" (без эмодзи и лишних пробелов); остальной текст не меняй.
C) ИДЕНТИФИКАТОР: найди ПЕРВЫЙ идентификатор:
   • «🆔 XX-1234» (XX — латинские заглавные, 1234 — цифры) ИЛИ
   • «🆔 8581» (только цифры).
   УДАЛИ его из текста и верни "vacancy_id" (без символа 🆔). Если нет — None.
D) СТАВКА
  • Базовая извлекаемая ставка ("rate"):
  • Если найдено хотя бы одно число (одиночное или диапазон), сформируй "rate" как объект по юрисдикциям.
  • Если единственное число без пометок и витрина допускает РФ+РБ → рассчитай:
      "rate" = {{"РФ": amount_RF, "РБ": floor(amount_RF*0.83)}}
  • Если диапазон «N–M» без пометок и витрина допускает РФ+РБ → рассчитай по нижней границе:
      "rate" = {{"РФ": N, "РБ": floor(N*0.83)}}
  • Если даны две ставки «РФ» и «не РФ» → "rate" = {{"РФ": amount_RF, "РБ": amount_non_RF}}
  • Если указано только «для РФ» (и витрина допускает РБ) → "rate" = {{"РФ": amount_RF, "РБ": floor(amount_RF*0.83)}}
  • Если указано только «для не РФ» (и витрина допускает РФ) → "rate" = {{"РФ": null, "РБ": amount_non_RF}}
  • Если витрина допускает только одну юрисдикцию (например, только РФ) — "rate" выводи только с этой юрисдикцией (вторая = null).
  • Если ставки НЕТ → "rate"=0
E) ТРЕБОВАНИЯ (объединение «плюсов» с основными):
   G1. Основной список — разделы «Требования», «Основные требования», «Обязательные требования»,
       англ.: «Requirements», «Required», «Must have». Если их нет, но есть «плюсы» — создай раздел «Требования»
       и помести его на место первого найденного блока требований/«плюсов».
   G2. Что считать «плюсами» (без учета регистра/пунктуации; кавычки/маркеры НЕ обязательны):
       — Заголовки/подзаголовки/фразы: «будет плюсом», «будет большим плюсом», «будет преимуществом»,
         «большим преимуществом будет», «плюсом», «плюсом будет», «как плюс»,
         «желательно», «предпочтительно», «не обязательно, но желательно», «опционально», «Доп. требования:»;
         англ.: «nice to have», «good to have», «would be a plus», «big/strong plus», «preferred»,
         «optional», «bonus», «as an advantage», «advantageous».
       — Фразы-связки с «если»: распознавай конструкции «будет плюсом(,|—|-|:)?\s*если …»
         (в т.ч. «Будет плюсом если вы …») — с любыми знаками препинания или без — и относись к ним как к «плюсам».
       — Эти фразы могут встречаться в заголовке раздела, внутри пункта, в начале/конце предложения,
         в скобках («…(будет плюсом)»), с эмодзи/символами (напр. «➕», «+», «🌟», «⭐») или без них — во всех случаях
         считай такой пункт «плюсом».
   G3. Что НЕ считать «плюсами»: разделы про условия/бонусы/преимущества работодателя
       («Преимущества», «Бонусы», «Мы предлагаем», «Benefits», «Perks», «Conditions», «Условия»), а также
       «Задачи/Обязанности/Responsibilities/What you will do».
   G4. Как объединять:
       — Вырежи ТОЛЬКО заголовки «плюсов»/вводные слова, сами пункты оставь как есть.
       — Если «плюсы» перечислены одной строкой через запятые — перенеси строку целиком как один пункт,
         не меняя пунктуации.
       — Если пометка «(будет плюсом/optional/…)» стоит в конце пункта, перенеси пункт в конец списка
         требований и УДАЛИ только скобочную пометку.
       — Порядок: 1) исходные обязательные пункты (как были), 2) затем все «плюсы» в порядке появления сверху вниз.
       — Дубли: убери точные дубликаты (trim + без финальной точки/«;»). Семантические различия — не объединяй.
H) ДЕДЛАЙН (извлечение значений, НЕ отсев здесь): определи срок подачи резюме ().
   Верни  Дату  (до какого числа "deadline_date" = "DD.MM.YYYY" или None) и Время (до какого времени "deadline_time" = "HH:MM" или None).
I) СТРУКТУРА (напоминание): после всех манипуляций глобально соблюдай правило сохранения структуры текста
   (см. блок «ГЛОБАЛЬНОЕ ПРАВИЛО СОХРАНЕНИЯ СТРУКТУРЫ»).
K) Если встречаются фразы/эквиваленты (любой регистр/язык):
    «акты поквартально», «квартальное актирование», «поквартальная оплата», «актирование», «ежеквартально»,
    «quarterly invoicing/billing», «net 60», «net 90», «N60», «N90», «deferred payment», «post-payment».
    Верни "acts" = true. В противном случае — false.

L) Если в тексте указана длительность проекта менее 6 месяцев (например: "3 месяца", "4 мес.", "полгода", "до 5 месяцев", "3 мес+"), то возвращай short_project: true.
    Если указано "от N месяцев", то это нижняя граница, а не ограничение сверху. В этом случае не считай проект коротким, даже если N < 6.
    Если указано "от N до M месяцев", смотри на верхнюю границу: если M < 6, то short_project: true, иначе false.
    Если указано "до конца года", "с возможностью продления", или другая формулировка, явно предполагающая срок ≥ 6 месяцев, то short_project: false.
    В остальных случаях — short_project: false.

M) Если встречаются фразы вида:

    - "Отсрочка платежа ..."
    - "Отсрочка ..."
    - "Условия оплаты: отсрочка ..."
то верни содержимое после слова "отсрочка" в переменной delay_payment, удаляя само слово и лишние пробелы. Иначе — delay_payment: null.

N) Если в отсрочка платежа больше 35 рабочих дней или 50 календарных дней, верни long_payment: true, иначе — long_payment: false.


O) Если в тексте встречаются фразы:
              - "Только штатные кандидаты"
              - "Рассматриваем только штатных кандидатов"
              - "Оформление только штат компании"
            то верни only_fulltime: true, иначе — only_fulltime: false.

P) Оставь в тексте срок подачи резюме

Q) УДАЛИ ИЗ ТЕКСТА ИМЯ И ФАМИЛИЮ В БЛОКЕ Вопросы и предложения. Пример блока:
Вопросы и предложения Михаил Сазанович ➡️@sazanovich_ma или в общий чат.

ФОРМАТ ОТВЕТА — СТРОГО СЛОВАРЬ:
{{
  "text": "<очищенный текст вакансии>" или null (если отсечена),
  "rate": {{"РФ": <целое число>, "РБ": <целое число>}} или 0 или null,
  "deadline_date": "DD.MM.YYYY" или null,
  "deadline_time": "HH:MM" или null,
  "vacancy_id": "<id или null>",
  "vacancy_title": "<заголовок или null>",
  "acts": true или false,
  "short_project": true или false
  "delay_payment": "<содержимое фразы или null>",
  "only_fulltime": true или false,
  "location": ["РФ", "РБ"] или [],
  "long_payment": true или false
  "reason": "<причина отсева или null>",
  "utochnenie": true или false
}}
Никаких других слов/символов не добавляй. Не используй Markdown/код-блоки в ответе.
"""

    # Модель Gemini
    model = genai.GenerativeModel('gemini-2.5-pro')
    generation_config = genai.types.GenerationConfig(temperature=0.1)
    
    full_prompt = system_prompt + "\n\nТекст вакансии:\n\n" + text

    try:
        response = await model.generate_content_async(
            full_prompt,
            generation_config=generation_config
        )

        clean_text = response.text.strip()
        print("✅ Ответ от Gemini получен.")
        

        # Проверка на отсечение вакансии
        if clean_text.lower() == 'null':
            print("❌ Вакансия отфильтрована.")
            return None

        # Попытка извлечения JSON
        json_match = re.search(r'\{.*\}', clean_text, re.DOTALL)
        if json_match:
            try:
                return json.loads(json_match.group(0))
            except json.JSONDecodeError as e:
                print(f"Ошибка парсинга JSON: {e}")
                return None
        else:
            print("JSON не найден в ответе модели.")
            return None

    except Exception as e:
        print(f"Ошибка при вызове Gemini API: {e}")
        return None



async def format_vacancy_gemini(text: str, vacancy_id: str, date: str | None = None) -> str:
    """
    Функция для структурированного оформления вакансии с помощью Gemini API.
    Возвращает готовый текст в нужном формате.
    """
    if date is None:
        date = datetime.now().strftime("%d.%m.%Y")

    print(f"[*] Форматируем вакансию ID: {vacancy_id} от {date}...")

    prompt = f"""
Ты — редактор вакансий.
На вход ты получаешь текст вакансии. Твоя задача — оформить его в структурированном виде для публикации, строго соблюдая формат.

⚡️ ВАЖНО:
— Никогда не удаляй и не изменяй HTML-тэги (<s>, <b>, <i> и любые другие).
— Особенно не трогай тэги вокруг следующих строк:
  * «ИП: ...»
  * «Самозанятый: ...»
  * «- Ежемесячная выплата Штат/Контракт»
— Эти элементы должны оставаться с тэгами в исходном виде.
— Никогда не добавляй и не убирай теги <s> (или любые другие HTML-теги).
— Если в исходном тексте строка уже содержит <s>…</s> — оставляй как есть.
— Если в исходном тексте строки без <s> — не добавляй зачеркивание самостоятельно.
— Решение о том, какие строки должны быть зачёркнуты, принимается не тобой, а логикой до передачи текста (ты работаешь только с готовым набором тегов).
— Определи, какие страны указаны в тексте:
   * если есть РБ/Беларусь/Belarus/BY → добавь блок 🇧🇾;
   * если есть РФ/Россия/Russia/RU/Москва → добавь блок 🇷🇺;
   * если есть обе — добавь оба блока в указанном порядке (сначала 🇧🇾, потом 🇷🇺);
   * если нет упоминаний — не добавляй флаг, оставь общий блок со ставкой.
— Не придумывай страны, которых нет в тексте.

⚡️ Правила форматирования:
— Всегда выводи строку {date}, даже если в тексте уже есть другая дата.
— Строка {date} должна идти сразу после {vacancy_id}.
— В названии должности всегда указывать грейд (Junior / Middle / Senior / Lead), если он есть.
— Раздел «Будет плюсом» включается в общий список «💻 Требования» (без отдельного блока).
— Каждый пункт требований — отдельной строкой с маркером.
— Между разделами и блоками вакансии должна быть ровно 1 пустая строка.
— В тексте вакансии не должно быть 2 и более пустых строк подряд.
— Не удаляй и не сокращай информацию, используй все данные из текста.
— Блок «⚠️ Особые условия» включай только если в тексте реально есть данные (NDA, кол-во этапов интервью, оформление и т.д.).

🔥 Дополнительное требование:
Если в исходном тексте не указана ставка (RUB, USD, у.е., вилка и т.п.),
в блоке 💰 "Месячная ставка (на руки) до:" вместо суммы напиши:
«Рассматриваем ваши предложения».

⚡️ Структура итогового текста:

🆔{vacancy_id}
📅 Дата публикации: {date}

🥇 [Название должности] ([Грейд])


 🇧🇾💰 Месячная ставка для юр лица РБ:
Вариант 1. Ежемесячная выплата Штат/Контракт (на руки) до: 260 000 RUB (с выплатой зарплаты 11 числа месяца следующего за отчетным)

Вариант 2. Выплата ИП/Самозанятый
С отсрочкой платежа 35 рабочих дней после подписания акта:
(Актирование: ежемесячное):
2700 RUB/час (Gross)
Справочно в месяц (при 170 раб. часов): 445 000 RUB(Gross)


 🇷🇺💰 Месячная ставка для юр лица РФ:
Вариант 1. Ежемесячная выплата Штат/Контракт (на руки) до: 260 000 RUB (с выплатой зарплаты 11 числа месяца следующего за отчетным)

Вариант 2. Выплата ИП/Самозанятый
С отсрочкой платежа 35 рабочих дней после подписания акта:
(Актирование: ежемесячное):
2700 RUB/час (Gross)
Справочно в месяц (при 170 раб. часов): 445 000 RUB(Gross)

Вариант 2. Выплата ИП/Самозанятый: 211 000 RUB


📍 Локация/Гражданство: [страны, города]
🏠 Формат работы: [удалённо / офис / гибрид]
🎓 Грейд: [Junior / Middle / Senior / Lead]
📆 Срок проекта: [сроки]
🚀 Старт проекта: [ASAP или дата]

📌 О проекте:
[Краткое описание проекта]

📎 Задачи:
— [Перечислить задачи из вакансии]

💻 Требования:
— [Обязательное требование 1]
— [Обязательное требование 2]
— [Будет плюсом 1]
— [Будет плюсом 2]

⚠️ Особые условия:
— [NDA, кол-во этапов интервью, трудоустройство и т.д.]

❗️ Обязательные данные по кандидату при подаче:
● ФИО
● Страна + Город
● Дата рождения (не возраст, а дата)
● Электронная почта
● Образование (ВУЗ, год окончания, специальность)
● Грейд
● Ставка
● Чек-лист соответствия требованиям (ДА/НЕТ)

Контакт для вопросов: [имя + @Telegram]

---
Вот текст вакансии для обработки:

{text}
"""

    model = genai.GenerativeModel('gemini-2.5-pro')
    generation_config = genai.types.GenerationConfig(temperature=0.1)

    try:
        response = await model.generate_content_async(prompt, generation_config=generation_config)
        return response.text.strip()
    except Exception as e:
        print(f"🔥 Ошибка при форматировании вакансии: {e}")
        return False


async def generate_hashtags_gemini(vacancy_text: str) -> str:
    """
    Генерирует хэштеги из текста вакансии с помощью Gemini API.
    """
    print("[*] Генерируем хэштеги...")
    
    prompt = f"""
Вот текст вакансии:

{vacancy_text}

Сформируй список хэштегов в одну строку через пробел.

Правила:
1. По технологиям/стеку (например: #Java #Spring #PostgreSQL #Docker) — извлеки их из описания.
2. По грейду: #Junior или #Middle или #Senior — определи из текста.
3. По отрасли (например: #Fintech #Retail #Banking) — определи по контексту.

Выведи только строку с хэштегами.
"""
    
    model = genai.GenerativeModel('gemini-2.5-flash')
    generation_config = genai.types.GenerationConfig(temperature=0.1)
    
    try:
        response = await model.generate_content_async(prompt, generation_config=generation_config)
        return response.text.strip()
    except Exception as e:
        print(f"🔥 Ошибка при генерации хэштегов: {e}")
        return False





async def sverka_vac_and_resume_json(vacancy_text, resume_text, file_name):
    """
    Анализирует соответствие кандидата вакансии и возвращает JSON от Gemini без очистки.
    Логика Omega Solutions v3.4:
    — Если нет имени, фамилии, локации или зарплаты → "Нет (требуется уточнение)" (ошибка оформления, не влияет на вердикт)
    — Все прочие отсутствующие требования → "Нет (точно нет)"
    — Если >=70% must_have совпало → остальные "Нет (требуется уточнение)"
    """
    print(file_name)
    prompt = f"""
Ты — продвинутый ассистент IT-рекрутера компании Omega Solutions.
Ты оцениваешь соответствие кандидата требованиям вакансии и возвращаешь строго валидный JSON без текста вне объекта.

Входные данные о файле кандидата:
Имя файла (строка для разбора): "{file_name}"

Разбери строку как данные и выполни следующие действия:
1. Раздели строку на слова по пробелам, подчёркиваниям и точкам.
2. Определи слова, начинающиеся с заглавной буквы на кириллице или латинице — это части ФИО (первое — фамилия, второе — имя).
3. Если встречается число рядом с обозначением валюты (`RUB`, `руб`, `₽`, `USD`, `$`, `у.е`, `EUR` и т.д.) — это зарплатные ожидания.
4. Если в числе есть пробелы, убери их: `400 000 RUB` → `400000 RUB`.
5. Если валюта указана буквами (например, "RUB", "USD", "у.е") — оставь её как есть, не переводя.
6. Верни это значение в поле "summary.salary_expectations" и продублируй в "candidate.salary_expectations", если оно есть.
7. Если сумма не найдена — поставь "нужно уточнить".

Цель
— Проведи профессиональную сверку резюме и вакансии: оцени выполнение всех обязательных (must_have) и дополнительных (nice_to_have) требований; оцени полноту данных (ФИО, отчество, дата рождения, город, контакты, зарплата).
— Оформи результат строго в JSON по схеме ниже.

Правила обработки
1. Всегда возвращай только один валидный JSON-объект — без Markdown, без текста до/после.
2. Не используй null. Если данных нет — ставь "Нет (требуется уточнение)" или "Нет (точно нет)".
3. Все имена, города, страны переводи на русский язык.
4. Если информации нет вообще — "Нет (точно нет)".
5. Формат дат — ДД.ММ.ГГГГ, возраст округляй до целых лет.

Анализ имени файла
Если в тексте резюме отсутствуют имя и фамилия или отчество, выполни следующие шаги:
1) Прочитай строку имени файла полностью: {file_name}
2) Раздели её по символам "_", "-", ".", пробелам.
3) Если слово содержит кириллицу или латиницу и начинается с заглавной буквы — это часть ФИО.
   Первые два таких слова считай:
   — первое → фамилия,
   — второе → имя.
   Примеры:
   • Ivan_Ivanov_BE10451.docx → Иван Иванов
   • Kurs_Aleksandr_Resume.docx → Александр Курс
   • Александр Курс 2200 у.е..docx → Александр Курс
4) Если слово содержит числа и валюту (USD, руб, у.е, $, EUR) — это зарплатные ожидания.
   Примеры:
   • Ivan_Ivanov_3500USD.docx → salary_expectations = "3500 USD"
   • Александр Курс 2200 у.е..docx → salary_expectations = "2200 у.е."

5) Если не найдено упомнинаний зарплатных ожиданий ни в резюме не в названиии файла — добавь требование для уточнения зарплатных ожиданий:
   {{
     "requirement": "Не указаны зарплатные ожидания",
     "status": "Нет (требуется уточнение)",
     "comment": "Зарплатные ожидания не определены ни в резюме, ни в названии файла"
   }}

6) Если в резюме и/или по имени файла не определено ИМЯ — добавь пункт:
   {{
     "requirement": "Наличие в резюме: Имя",
     "status": "Нет (требуется уточнение)",
     "comment": "Имя кандидата отсутствует в резюме и не извлечено из имени файла"
   }}

7) Если в резюме и/или по имени файла не определена ФАМИЛИЯ — добавь пункт:
   {{
     "requirement": "Наличие в резюме: Фамилия",
     "status": "Нет (требуется уточнение)",
     "comment": "Фамилия кандидата отсутствует в резюме и не извлечена из имени файла"
   }}

8) Если в резюме отсутствует ОТЧЕСТВО (и его нельзя надёжно извлечь из имени файла) — добавь пункт:
   {{
     "requirement": "Наличие в резюме: Отчество",
     "status": "Нет (требуется уточнение)",
     "comment": "Отчество не указано и не может быть достоверно извлечено из имени файла"
   }}

9) Фильтр вывода для Имя/Фамилия/Отчество:
    — Для этих трёх пунктов никогда не использовать статус "Нет (точно нет)".

ЛОГИКА СОВПАДЕНИЙ (уточнённая)
— Если обязательное требование явно и полностью отсутствует (например, требуемая технология не упомянута вообще в резюме) — ставь "Нет (точно нет)".
— Если навык или технология указаны в неполной форме (например, есть "Java", но нет версии "Java 21") — ставь "Нет (требуется уточнение)", а не отказ.
— Если навык из вакансии частично совпадает (например, в вакансии "Spring Boot", а в резюме просто "Spring") — ставь "Нет (требуется уточнение)".
— Если кандидат указал опыт с другой версией (например, "Java 8", а требуется "Java 21"), но общий опыт достаточный (≥ требуемого стажа) — также "Нет (требуется уточнение)".
— Если в резюме нет указания по вспомогательным инструментам (например, Jira, Docker, CI/CD) — "Нет (требуется уточнение)".
— Если явно указано, что у кандидата меньше опыта, чем требуется по вакансии (например, требуется ≥5 лет, а в резюме 3 года) — ставь "Нет (точно нет)".
— Если есть сомнение (не указано явно, но могло быть в опыте) — всегда "Нет (требуется уточнение)", а не отказ.

Таким образом:
- "Нет (точно нет)" = очевидное несоответствие или противоречие фактам.
- "Нет (требуется уточнение)" = информация отсутствует, неявна, версия не указана, опыт не расшифрован.
- "Да" = подтверждено явно.


Решения о вердикте (summary.verdict):
   — Если все must_have = "Да" → "Полностью подходит".
   — Если есть хотя бы один "Нет (точно нет)" по ключевым навыкам (например, Java нет или стаж меньше) → "Не подходит".
   — Если все must_have — "Да" или "Нет (требуется уточнение)" → "Частично подходит (нужны уточнения)".
ОСОБЫЕ ПРАВИЛА
— Отсутствие фамилии, имени, отчества, локации, зарплатных ожиданий, даты рождения, контактов, образования или опыта работы влияет на итоговый вердикт. Эти пункты отмечаются как "Нет (требуется уточнение)" и записываются в must_have.
— Все профессиональные навыки, которых нет в резюме, оценивай строго как "Нет (точно нет)".

ВЕРДИКТ (summary.verdict)
— Если в must_have есть хотя бы один пункт "Нет (точно нет)", кроме полей "ФИО", "Имя", "Фамилия", "Дата рождения", "Возраст", "Локация", "Город", "Контакты" → тогда "Не подходит".
— Если таких критических пунктов нет, но есть "Нет (требуется уточнение)" → "Частично подходит (нужны уточнения)".
— Если все must_have = "Да" → "Полностью подходит".
АЙДИ 
-Айди это цифры и буквы в начале вакансии например 10261, QA-10261, 1C-10261
-Айди должно быть передано в переменную 'position_id'
Структура JSON
{{
  "vacancy": {{
    "position_id": "<ID вакансии или Нет (требуется уточнение)>",
    "position_name": "<Название позиции или Нет (требуется уточнение)>",
    "grade": "<Грейд или Нет (требуется уточнение)>",
    "location_requirements": {{
      "location": "<Локация или Нет (требуется уточнение)>",
      "citizenship": "<Гражданство или Нет (требуется уточнение)>",
      "timezone": "<Часовой пояс или Нет (требуется уточнение)>"
    }},
    "work_format": "<remote/office/hybrid или Нет (требуется уточнение)>",
    "tech_stack": ["<Технология 1>", "<Технология 2>"],
    "requirements": {{
      "must_have": ["<Обязательное требование 1>", "<Обязательное требование 2>"],
      "nice_to_have": ["<Дополнительное требование 1>", "<Дополнительное требование 2>"]
    }},
    "special_conditions": {{
      "nda": "<да/нет/Нет (требуется уточнение)>",
      "sim_card": "<требуется/не требуется/Нет (требуется уточнение)>",
      "rate": "<ставка или Нет (требуется уточнение)>",
      "deadlines": "<дедлайны или Нет (требуется уточнение)>"
    }},
    "manager_telegram_nickname": "@Dimitryver"
  }},
  "candidate": {{
    "full_name": "<Фамилия Имя Отчество или Фамилия Имя>",
    "birth_date": {{
      "date": "<ДД.ММ.ГГГГ или Нет (требуется уточнение)>",
      "age": "<число лет или Нет (требуется уточнение)>"
    }},
    "location": {{
      "city": "<Город или Нет (требуется уточнение)>",
      "country": "<Страна или Нет (требуется уточнение)>"
    }},
    "grade_and_position": "<Грейд/позиция кандидата или Нет (требуется уточнение)>",
    "full_experience": "<Опыт в IT или Нет (требуется уточнение)>",
    "experience": [
      {{
        "company_name": "<Компания>",
        "role": "<Роль>",
        "domain": "<Домен или Нет (требуется уточнение)>",
        "period": "<Период работы>",
        "projects": [
          {{
            "project_description": "<Описание проекта>",
            "responsibilities": ["<Обязанность 1>", "<Обязанность 2>"],
            "technologies_used": ["<Технология 1>", "<Технология 2>"]
          }}
        ]
      }}
    ],
    "tech_stack": ["<Технология 1>", "<Технология 2>"],
    "languages": [
      {{
        "language": "<Язык>",
        "level": "<Уровень>"
      }}
    ],
    "contacts": {{
      "phone": "<Телефон или Нет (требуется уточнение)>",
      "email": "<Email или Нет (требуется уточнение)>",
      "telegram": "<Telegram или Нет (требуется уточнение)>",
      "linkedin": "<LinkedIn или Нет (требуется уточнение)>"
    }},
    "salary_expectations": "<Сумма или нужно уточнить>"
  }},
  "compliance_check": {{
    "must_have": [
      {{
        "requirement": "<требование>",
        "status": "<Да | Нет (требуется уточнение) | Нет (точно нет)>",
        "comment": "<обоснование>"
      }}
    ],
    "nice_to_have": [
      {{
        "requirement": "<требование>",
        "status": "<Да | Нет (требуется уточнение)>",
        "comment": "<обоснование>"
      }}
    ]
  }},
  "summary": {{
    "verdict": "<Полностью подходит | Частично подходит (нужны уточнения) | Не подходит>",
    "salary_expectations": "<Сумма / 'нужно уточнить'>"
  }}
}}

Детерминация (сделай результаты стабильными)
— Используй строго фиксированный словарь статусов: Да, Нет (требуется уточнение), Нет (точно нет). Другие формулировки запрещены.
— Сравнение по стеку делай после нормализации:
  — приведи регистр к нижнему, удали диакритику, убери дефисы/точки/подчеркивания внутри токенов;
  — разверни синонимы/аббревиатуры по словарю ниже (k8s → kubernetes, ts → typescript и т.д.);
  — сравнивай по точным токенам либо по известным биграммам (react + typescript считается совпадением для "react typescript").
— Для чисел и диапазонов зарплат: распознай 12 000, 12,000, 12000, 12k, 12K; 12k трактуй как 12000.
— Валюты распознай по символам/тегам (₽, руб, RUB; $, USD; €, EUR; у.е. = USD).
— Даты распознавай в форматах ДД.ММ.ГГГГ, ГГГГ-ММ, ММ/ГГГГ; в выводе всегда ДД.ММ.ГГГГ.
— Если в резюме и вакансии есть противоречие, применяй приоритет доказательств:
  1) Явная формулировка в резюме (описание обязанностей/стек в проекте).
  2) Сводный список навыков в резюме.
  3) Ключевые слова вне контекста (перечни без описаний).
  Если доказательства равноценны, ставь "Нет (требуется уточнение)".
— Запрещены домыслы без опоры на текст. Любая неочевидная интерпретация → "Нет (требуется уточнение)".



Словарь синонимов/конвертаций (для нормализации)
— Языки/стек:
  — js → javascript; ts → typescript; nodejs → node.js; reactjs → react; react.js → react; vue.js → vue; angularjs → angular
  — k8s → kubernetes; gke → google kubernetes engine; eks → aws elastic kubernetes service; aks → azure kubernetes service
  — aws → amazon web services; gcp → google cloud platform; azure → microsoft azure
  — postgres → postgresql; mssql → sql server; es → elasticsearch; elk → elasticsearch logstash kibana
  — ci/cd → cicd; gitlab-ci → cicd; github actions → cicd; jenkins → cicd
  — spring → spring framework; springboot → spring boot; jpa → hibernate jpa
  — py → python; tf → terraform; ansible → ansible; docker-compose → docker compose
— Уровни языка:
  — A1/A2/B1/B2/C1/C2 сохраняй как исходные, допускается B2+ → "B2+".
— Форматы занятости:
  — remote → remote; офис/office → office; гибрид/hybrid → hybrid.
(Примечание: синонимы используются только для нормализации и сопоставления. В JSON сохраняй канонические формы из левой части: react, typescript, kubernetes, cicd, postgresql, elasticsearch, spring boot, terraform и т.д.)

Контрольный чек-лист (выполняй перед финализацией результата вне JSON, но учитывай в комментариях):
A) Полнота — все факты сохранены, ничего не потеряно или не сокращено.
B) Формат имён — если требуется «ФИО», указаны фамилия, имя, отчество; если «ФИ» — отчество не требуется.
C) Соответствие — обязательные требования закрыты статусами; дополнительные — оформлены с комментариями; при частичных совпадениях не домысливай.
D) Зарплата/контакты — корректно извлечены или помечены как "нужно уточнить".



100% ПОКРЫТИЕ ТРЕБОВАНИЙ (ОБЯЗАТЕЛЬНО К ВЫПОЛНЕНИЮ)
A) Извлечение требований из текста вакансии

Сначала дословно извлеки все требования из текста вакансии и раздели их на:
— must_have (обязательные)
— nice_to_have (дополнительные)

Маркеры для must_have (если секции явно не подписаны):
— слова и фразы: обязательно, требуется, must have, обязателен, must, необходимо, только при наличии, без этого не рассматриваем, минимальные требования, твердо требуется, strictly required.

Маркеры для nice_to_have (если секции явно не подписаны):
— слова и фразы: желательно, будет плюсом, желание, приветствуется, опционально, optional, nice to have, хорошо бы, как плюс, предпочтительно.

Если в вакансии есть явные заголовки/списки (например, «Обязательные требования» / «Будет плюсом»), используй их как источник приоритета. Если разметки нет — классифицируй по маркерам из п.2–3.

B) Атомаризация и нормализация требований

Каждое требование должно быть атомарным: одна технология/скилл/условие = один элемент списка.
— Пример: Опыт 3+ лет: Java, Spring, Hibernate → три элемента в том же порядке:
Опыт 3+ лет: Java
Опыт 3+ лет: Spring
Опыт 3+ лет: Hibernate
— Пример: React/Angular/Vue → три элемента: React, Angular, Vue.

Сохраняй смысловые модификаторы у каждого атомарного требования: стаж (2+ года), уровень (Senior), контекст (коммерческий опыт, продакшен-эксплуатация), домен (финтех), инструменты (GitLab CI, Docker, Kubernetes).
— Пример: Продакшен-опыт 2+ лет: Kubernetes (а не просто Kubernetes).

Нормализуй синонимы по словарю из промпта (ts → typescript, k8s → kubernetes и т. д.), но сохраняй исходную семантику требования (стаж/уровень/контекст не терять).

Удаляй дубликаты, сохраняя первое вхождение и исходный порядок из вакансии.

Слово или трактуй как альтернативы: разделяй на несколько атомов, каждый отдельным пунктом.
— Пример: Опыт: PostgreSQL или MySQL → два требования: Опыт: PostgreSQL, Опыт: MySQL.

C) Инварианты полноты (нельзя нарушать)

Запрет пропусков: каждый пункт, который можно разумно интерпретировать как требование, обязан оказаться в одном из списков must_have или nice_to_have. Если сомневаешься, отнеси в nice_to_have и пометь в комментарии Нужно подтверждение классификации.

Запрет добавлений: не придумывай требований, которых нет в тексте (кроме атомаризации/нормализации по правилам выше).

Порядок: сохраняй порядок следования из вакансии; атомы внутри составного требования располагай в исходном локальном порядке.

D) Жёсткая синхронизация requirements ↔ compliance_check

Строки в compliance_check.must_have[*].requirement должны быть бит-в-бит равны соответствующим строкам в vacancy.requirements.must_have[*].

Строки в compliance_check.nice_to_have[*].requirement должны быть бит-в-бит равны соответствующим строкам в vacancy.requirements.nice_to_have[*].

Размеры массивов обязаны совпадать:

len(vacancy.requirements.must_have) == len(compliance_check.must_have)

len(vacancy.requirements.nice_to_have) == len(compliance_check.nice_to_have)

Запрещены «лишние» пункты в compliance_check, которых нет в vacancy.requirements, и наоборот — запрещены «потерянные» пункты.

E) Статусы и комментарии

Для каждого элемента из requirements.must_have и requirements.nice_to_have обязан быть сформирован статус в compliance_check по фиксированному словарю: Да | Нет (требуется уточнение) | (для профессиональных навыков допускается) Нет (точно нет).

Комментарий должен обосновывать статус: где найдено подтверждение (фрагмент опыта/проект/технологии) или что именно отсутствует/нужно уточнить.

F) Проверка перед выдачей JSON

Выполни контрольные проверки (если нарушены — пересчитать до соответствия):

Все требования из вакансии присутствуют в vacancy.requirements.* и отражены 1-в-1 в compliance_check.*.

Длины массивов совпадают (см. п.15).

Нет дубликатов и нет пустых строк.

Сохранён исходный порядок.

G) Совместимость с блоком «Наличие в резюме: …»

Правила про «Наличие в резюме: ФИО/Локация/Дата рождения/Электронная почта/Образование» сохраняются:
— эти пункты выводить только если отсутствуют/неполные (статус Нет (требуется уточнение)),
— если всё в порядке — не выводить их вообще.
— Эти проверки не влияют на полноту списков требований и не заменяют профессиональные требования.

РЕЖИМ «ОДНА СТРОКА → ОДИН ПУНКТ» (СТРОГО ОБЯЗАТЕЛЬНО)

Сохранение строки без изменений
— Каждое требование берётся целиком одной строкой ровно в том виде, как в тексте вакансии (включая запятые, скобки, «/», «или», двоеточия, примеры и т. п.).
— Запрещено разбивать одну строку на несколько пунктов (никакой атомизации).
— Порядок строк сохраняется.

1-в-1 синхронизация блоков
— Каждый пункт из vacancy.requirements.must_have и vacancy.requirements.nice_to_have должен бит-в-бит совпадать с соответствующим пунктом в compliance_check.must_have/compliance_check.nice_to_have в поле "requirement".
— Размеры массивов должны совпадать:
len(vacancy.requirements.must_have) == len(compliance_check.must_have)
len(vacancy.requirements.nice_to_have) == len(compliance_check.nice_to_have)
— Пункты, которых нет в вакансии, в compliance_check запрещены. Пропуски запрещены.

Как оценивать составные строки (внутренне, без изменения текста пункта)
— Если в строке перечисление через запятые без слов «или»/«/» → трактуй как И (AND): статус "Да", только если подтверждены все перечисленные элементы; иначе "Нет (требуется уточнение)" (или "Нет (точно нет)", если явно отсутствует).
— Если в строке встречается «или» или «/» между элементами → трактуй как ИЛИ (OR): достаточно подтверждения любого из альтернатив для статуса "Да"; если все альтернативы не подтверждены — "Нет (требуется уточнение)" (или "Нет (точно нет)", если явно отсутствует).
— Примеры (выводим одной строкой!):
• «Профессиональное владение технологиями: Java SE, Spring (ядро, Boot, Cloud), PostgreSQL, Microsoft SQL Server» → AND-логика.
• «Опыт: PostgreSQL / MySQL» или «PostgreSQL или MySQL» → OR-логика.

Комментарий к статусу
— В comment кратко обоснуй решение, но не изменяй и не дублируй текст требования.
— Для AND: перечисли, что подтверждено и чего не хватает (в 1–2 фразах).
— Для OR: укажи, какие альтернативы подтверждены/не подтверждены.

Совместимость с блоком «Наличие в резюме: …»
— Правила стандартизации лейблов («ФИО», «Локация», «Дата рождения», «Электронная почта», «Образование») сохраняются.
— Эти пункты выводить только если отсутствуют/неполные (статус "Нет (требуется уточнение)").
— Если статус "Да" — не выводить их вообще (строго удалить перед финальным JSON).

Инварианты перед выводом
— Нет ни одного требования, которого не было в тексте вакансии.
— Нет ни одного пропущенного требования.
— Текст каждого требования в обеих секциях совпадает символьно между vacancy.requirements.* и compliance_check.*.
— Для «Наличие в резюме: …» отсутствуют элементы со статусом "Да" (они удалены).

СТАНДАРТИЗАЦИЯ ЛЕЙБЛОВ ДЛЯ ПРОВЕРОК ПОЛНОТЫ (ИСПОЛЬЗОВАТЬ СТРОГО ТАК)

Всегда использовать ровно следующие лейблы в текстах требований/комментариях/полях requirement:

Наличие в резюме: ФИО

Наличие в резюме: Локация (замена любых форм «Страна + Город», «Город/Страна», «City/Country»)

Наличие в резюме: Дата рождения

Наличие в резюме: Контакты

Наличие в резюме: Образование (замена форм «Образование (ВУЗ, год окончания, …)» и т.п.)

Эмодзи статусов (если используются в тексте комментариев):

Есть → ✅

Нужно уточнить/нет данных → ⚠️

Примеры корректных формулировок внутри JSON:

{{
  "requirement": "Наличие в резюме: Локация",
  "status": "Нет (требуется уточнение)",
  "comment": "⚠️ Указан город без страны"
}}

{{
  "requirement": "Наличие в резюме: Образование",
  "status": "Да",
  "comment": "✅ ВУЗ и год окончания присутствуют"
}}



ЖЁСТКИЙ ФИЛЬТР ВЫВОДА «НАЛИЧИЕ В РЕЗЮМЕ»

Выполни этот порядок строго перед формированием финального JSON:
Сначала вычисли статусы для пяти проверок полноты по стандартизированным лейблам:
Наличие в резюме: ФИО
Наличие в резюме: Локация
Наличие в резюме: Дата рождения
Наличие в резюме: Контакты
Наличие в резюме: Образование
Применить нормализацию лейблов:

Любые формы «Страна + Город», «Город/Страна», «City/Country» → «Наличие в резюме: Локация»
Любые формы «Образование (ВУЗ, год окончания, …)» → «Наличие в резюме: Образование»
Пост-фильтрация перед выводом:

Удалить из compliance_check.must_have и compliance_check.nice_to_have все элементы, где
requirement ∈ {{"Наличие в резюме: ФИО", "Наличие в резюме: Локация", "Наличие в резюме: Дата рождения", "Наличие в резюме: Электронная почта", "Наличие в резюме: Образование"}} и status = "Да".
Оставлять только те элементы из этого набора, у которых status = "Нет (требуется уточнение)".
Для этих пяти проверок никогда не использовать status = "Нет (точно нет)".
Инварианты проверки (если нарушены — пересчитать перед выводом):
В финальном JSON запрещено наличие элементов с requirement, начинающимся на Наличие в резюме: и status = "Да".

Если все пять полей присутствуют и корректны, в compliance_check.* не должно быть ни одного элемента Наличие в резюме: ….

Примеры (не включать в JSON, это контроль логики):

Было (неправильно):

{{ "requirement": "Наличие в резюме: Локация", "status": "Да", "comment": "✅ Город и страна указаны" }}


Стало (правильно): элемент удалён и не выводится.

Было:

{{ "requirement": "Наличие в резюме: Образование (ВУЗ, год окончания)", "status": "Нет (требуется уточнение)", "comment": "Нет года" }}


Стало (правильно, с нормализацией лейбла):

{{ "requirement": "Наличие в резюме: Образование", "status": "Нет (требуется уточнение)", "comment": "Требуется ВУЗ и год окончания" }}




Любые иные варианты лейблов («Страна + Город», «Образование (ВУЗ, год окончания, …)» и т.п.) запрещены — заменяй на стандартизированные формы выше.
Если что-то из этих лейблов имеет статус "Да" то удали его из json оставь только где статус "Нет (требуется уточнение)".

Определяй наличие контактов по полям candidate.contacts:
— phone
— email
— telegram
— linkedin

Правило показа:
— Если ХОТЯ БЫ ОДНО из этих полей присутствует и не равно "Нет (требуется уточнение)" → пункт «Наличие в резюме: Контакты» НЕ ВЫВОДИТЬ (совсем не добавлять в JSON).
— Если ВСЕ четыре поля отсутствуют/пустые/равны "Нет (требуется уточнение)" → вывести РОВНО ОДИН пункт:
{{
    "requirement": "Наличие в резюме: Контакты",
    "status": "Нет (требуется уточнение)",
    "comment": "Отсутствуют телефон, e-mail, Telegram и LinkedIn"
  }}

Жёсткий пост-фильтр перед выводом:
— Удалить из compliance_check.* любые элементы, где requirement ∈ {"Наличие в резюме: Электронная почта","Наличие в резюме: Email","Наличие в резюме: Почта","Наличие в резюме: Телефон","Наличие в резюме: Telegram","Наличие в резюме: LinkedIn"} — такие отдельные пункты запрещены.
— Для «Наличие в резюме: Контакты» никогда не использовать статус "Нет (точно нет)".
— Для всех «Наличие в резюме: …» со статусом "Да" — не выводить (удалить перед финальным JSON).

Примеры (не включать в JSON):
✓ Есть email или telegram (или любой один из четырёх) → «Наличие в резюме: Контакты» не выводить.
✗ Нет ни phone, ни email, ни telegram, ни linkedin → вывести один пункт «Наличие в резюме: Контакты» со статусом "Нет (требуется уточнение)".




Входные данные
[ВАКАНСИЯ]
{vacancy_text}

[РЕЗЮМЕ]
{resume_text}
"""

    
    model = genai.GenerativeModel("gemini-2.5-flash")
    generation_config = genai.types.GenerationConfig(temperature=0.1)

    try:
        response = await model.generate_content_async(prompt, generation_config=generation_config)
        raw1 = response.text.strip()
        return raw1
    except Exception as e:
        print(f"🔥 Ошибка при анализе вакансии и резюме: {e}")
        return False







async def generate_mail_for_candidate_finalist(json_data: dict, user_name: str, group_id: int, thread_id: int):
  try:
    group_id = str(group_id)
    group_id = group_id.replace("-100", "")
    thread_id = str(thread_id)
    vacancy = json_data.get('vacancy', {})
    candidate = json_data.get('candidate', {})
    vac_id = vacancy.get('position_id', 'ID вакансии')
    
    
    must_have_candidate = json_data.get('compliance_check', {}).get('must_have', [])
    strong_points = []
    for must_have in must_have_candidate:
      if must_have['status'] == 'Да':
        strong_points.append(must_have['requirement'])
      elif must_have['status'] == 'Нет (требуется уточнение)':
        continue
      elif must_have['status'] == 'Нет (точно нет)':
        continue
    
    prompt = f"""
    Ты — ассистент IT-рекрутера. 
  Ты должен составить персонализированное письмо кандидату-финалисту.

  ⚙️ Формат вывода: только готовый текст письма, без Markdown, без пояснений и меток кода.

  ---

  🎯 Цель письма:
  1. Поблагодарить кандидата за отклик.
  2. Коротко и ясно представить вакансию (позиция, стек, формат, условия).
  3. Упомянуть сильные стороны кандидата (2–4 пункта, по данным из анализа).
  4. Пригласить подтвердить готовность к интервью.
  5. Использовать деловой, вежливый, но дружелюбный стиль (без излишнего официоза).

  ---

  📩 Структура письма:

  1️⃣ Приветствие:
  «Здравствуйте, {candidate['full_name']}!»  
  — Используй полное имя, включая отчество, если оно указано в JSON.  
  — Если отчество отсутствует, обращайся по имени и фамилии.

  2️⃣ Благодарность:
  «Благодарим вас за резюме и интерес к нашей вакансии.»

  3️⃣ Представление вакансии:

  - Укажи позицию {vacancy['position_name']}
  - Укажи айди вакансии <a href="https://t.me/c/{group_id}/{thread_id}">{vac_id}</a>
  - Укажи кратко 1–2 ключевые задачи (возьми из списка {vacancy['requirements']['must_have']})
  - Перечисли кратко стек технологий ({vacancy['tech_stack']}).
  - Опиши формат работы ({vacancy['work_format']}: офис / удалённо / гибрид).
  - Укажи особые условия, если есть ({vacancy['special_conditions']}, например NDA, SIM-карта, ставка и т. д.
  - Удали любые упоминания об условиях оплаты и зарплаты.
  - Не удаляй ссылку в айди вакансии.

  4️⃣ Сильные стороны кандидата:
  - Используй 2–4 релевантных пункта на основе списка {strong_points}.
  - Примеры: «Опыт работы с Python более 3 лет», «Разработка микросервисов», «Знание Docker и Kubernetes», «Опыт удалённой работы в распределённой команде».

  5️⃣ Заключение:
  «Если вам интересно обсудить детали, пожалуйста, подтвердите готовность к интервью — мы подберём удобное время.»

  6️⃣ Подпись:
  «С уважением,  
  {user_name}»
  ---

  ✍️ Твоя задача:
  Составь готовое письмо кандидату по вышеуказанным правилам на русском языке.
  Не используй шаблоны вроде “Уважаемый кандидат”, всегда подставляй имя.
  Не добавляй пояснений, просто выведи готовый текст письма.
  Удали в итоговом тексте любые упоминания об условиях оплаты , ставки, зарплаты и т.д.
  Сделай текст читаемым и визуально красивым. Вот пример:
  
  Здравствуйте, Максим Александрович!

  Спасибо за ваше резюме.
  Мы рассматриваем вас на позицию Разработчик-эксперт BPMSoft (<a href="https://t.me/c/{group_id}/{thread_id}">{vac_id}</a>) в рамках долгосрочного проекта по замещению CRM B2C.

  📌 Кратко о вакансии:
  — Разработка программных модулей BPMSoft по техническим требованиям;
  — Участие в обсуждении архитектуры и требований;
  — Интеграции с внешними системами;
  — Формат — удалённая полная занятость, поквартальная оплата.

  Ваш опыт по BPMSoft, C#, Ext JS и Angular полностью соответствует требованиям вакансии.
  Чтобы завершить сверку, пожалуйста, уточните:
  — используете ли вы в работе Kafka или аналогичный брокер сообщений?
  — работали ли вы с Swagger (OAS) и Postman для тестирования REST API?
  — применяете ли вы GitLab в практической разработке?

  Также просим подтвердить:
  — ваши зарплатные ожидания (2200 у.е. — актуальны?)
  — срок готовности выйти на проект;
  — формат оформления (ИП, самозанятый или штат).

  С уважением,
  {user_name}
  """

    model = genai.GenerativeModel('gemini-2.5-pro')
    generation_config = genai.types.GenerationConfig(temperature=0.1)

    
    response = await model.generate_content_async(prompt, generation_config=generation_config)
    return response.text.strip()
  except Exception as e:
      print(f"🔥 Ошибка при формировании письма кандидату: {e}")
      return False
    
    
    
async def generate_mail_for_candidate_utochnenie(json_data: dict, user_name: str, vacancy_text : str, group_id: int, thread_id: int):
  try:
    group_id = str(group_id)
    group_id = group_id.replace('-100', '')
    link = f"https://t.me/c/{group_id}/{thread_id}"
    vacancy = json_data.get('vacancy', {})
    vac_id = vacancy.get('position_id', '.')
    candidate = json_data.get('candidate', {})
    
    must_have_candidate = json_data.get('compliance_check', {}).get('must_have', [])
    utochnenie = []
    for must_have in must_have_candidate:
      if must_have['status'] == 'Да':
        continue
      elif must_have['status'] == 'Нет (требуется уточнение)':
        utochnenie.append(must_have['requirement'])
      elif must_have['status'] == 'Нет (точно нет)':
        continue
    

    prompt = f"""
Ты — продвинутый ассистент IT-рекрутера компании Omega Solutions.  
Ты должен составить готовое письмо кандидату для уточнения деталей.

---

📌 **Основные принципы:**
— Пиши строго по структуре ниже, без Markdown, кавычек и пояснений.  
— Используй живой деловой стиль, без излишнего официоза.  
— Структура письма должна быть читаемой и визуально аккуратной.  
— Если в списке {utochnenie} есть пункты, связанные с отсутствием ФИО, даты рождения или зарплатных ожиданий, обязательно включи их в уточнение.  
— Игнорируй “социальные” качества (ответственность, инициативность и т.п.) — уточняй только технические или фактические моменты.  
— Не пиши ничего о ставках, оплате, бюджете или деньгах.  

---
[ВАКАНСИЯ — СЫРОЙ ТЕКСТ]
{vacancy_text}

📩 **Структура письма:**

1️⃣ **Приветствие:**  
Здравствуйте, {candidate.get('full_name', 'коллега')}!  
(Если есть отчество — используй его. Если нет — только имя и фамилию.)

2️⃣ **Благодарность:**  
Спасибо за ваше резюме.  
Мы рассматриваем вас на позицию {vacancy.get('position_name')} (<a href="https://t.me/c/{group_id}/{thread_id}">🆔 {vacancy.get('position_id', '')}</a>) в рамках проекта нашего заказчика.

— Исключи любые упоминания об оплате.
-Не удаляй ссылку с айди из письма


Описание проекта:
— Извлеки 1–3 предложения ТОЛЬКО из блока [ВАКАНСИЯ — СЫРОЙ ТЕКСТ], разделов типа «О проекте», «Про проект», «Описание проекта». 
— Используй дословные фразы (не перефразируй), при необходимости склей через точку. 
— Если в тексте вакансии нет такого раздела — этот абзац не выводи.

Задачи:
— Извлеки 2–4 строки ТОЛЬКО из разделов «Задачи», «Обязанности», «Что делать». 
— Бери пункты с маркерами (—, -, •) или явные фразы; выводи дословно, по одному пункту в строку (без переформулировок).
— Если раздела с задачами нет — этот абзац не выводи.

Формат работы:
— Укажи формат, если он есть в тексте вакансии (например: удалённо / офис / гибрид).

Особые условия:
— Если присутствуют в тексте (например: NDA, SIM-карта, график, режим занятости) — перечисли одной строкой.
— Любые упоминания про оплату/ставки/зарплату — НЕ выводить.

Технологический стек:
— Перечисли ключевые технологии из [ВАКАНСИЯ — СЫРОЙ ТЕКСТ] и/или из {vacancy.get('tech_stack', [])} одной строкой через запятую, без лишних слов.


Полный перечень требований из запроса (ДОСЛОВНО и ПОЛНОСТЬЮ, без сокращений и объединений, сохраняй исходный порядок; запрещены «…», «и т.д.», «и др.», «etc.»; запрещено объединять строки):

[Обязательные]
— Извлеки КАЖДУЮ исходную строку требований из разделов «Требования:», «Обязательные требования:», «Требуется:», «Must have» и аналогов, а также все пункты с маркерами (—, -, •) под этими заголовками. ОДНА исходная строка = ОДНА строка здесь, без переформулировок и без разбиения.

[Дополнительные]
— Если есть разделы «Будет плюсом:», «Желательно:», «Nice to have», «Опционально:» и т.п., перечисли ДОСЛОВНО КАЖДУЮ строку из этих разделов, в исходном порядке (одна исходная строка = одна строка здесь).

Жёсткие правила:
— Даже если список длинный — выводи его ЦЕЛИКОМ. Никаких сокращений и эллипсисов.
— Если в исходной строке встречаются запятые, «/» или «или», всё равно выводи её КАК ЕДИНУЮ строку.
— Если явных заголовков «Обязательные/Дополнительные» нет, строки под «Требования» трактуй как [Обязательные].
— Если соответствующего раздела нет вовсе — не выводи его заголовок.

Примечания к извлечению:
— Не атомизируй: если исходная строка содержит перечисления через запятые или «/», «или» — выводи её как один пункт (ровно как в тексте).
— Если явных заголовков «Обязательные/Дополнительные» нет: строки под «Требования:» трактуй как [Обязательные].
— Если соответствующего раздела нет вовсе, этот блок не выводи.

4️⃣ **Соответствие кандидата:**  
Сравни стек кандидата ({candidate.get('tech_stack', [])}) с требованиями вакансии и подчеркни 2–3 совпадения.  
Напиши коротко:  
«Ваш опыт с [технологии/области] хорошо соответствует требованиям проекта.»  

5️⃣ **Блок уточнений:**
— Если {utochnenie} пуст → НЕ выводить этот блок вовсе.
— Начни строго с фразы: «ЧТОБЫ ЗАВЕРШИТЬ СВЕРКУ, ПОЖАЛУЙСТА, УТОЧНИТЕ:»
— Далее сформируй СПИСОК ВОПРОСОВ, где КАЖДЫЙ элемент {utochnenie} порождает ОДНУ отдельную строку-вопрос.
— ПРАВИЛА ФОРМИРОВАНИЯ (НЕ СОКРАЩАТЬ):
   • Вывести ВСЕ элементы из {utochnenie} БЕЗ ПРОПУСКОВ, в исходном порядке.
   • Запрещены «…», «и т.д.», «и др.», «etc.» и любые объединения.
   • Для анкетных пунктов (начинаются с «Наличие в резюме: …») задавай уточняющий вопрос («просим указать …»).
   • Для профессиональных требований задавай вопрос-подтверждение с конкретикой («просим подтвердить/описать опыт …, где именно применяли, на каких проектах»).
   • Если текст пункта длинный — переносить строку РАЗРЕШАЕТСЯ, но содержимое НЕ сокращать и НЕ перефразировать.
— Пример формата строки (шаблон, пример не выводить):
   — «просим подтвердить: (точный текст требования из {utochnenie}) (где применяли, какие проекты/инструменты)»


Добавь стандартный блок:  
«Также просим подтвердить:
— готовность к выходу после оффера (сроки);  
— формат оформления (штат, контракт, ИП, самозанятый);  

6️⃣ «Если у вас есть опыт по перечисленным выше пунктам, пожалуйста, обновите резюме.»

7️⃣ **Подпись:**  
С уважением,  
{user_name}  

---

✍️ **Инструкция для модели:**
— Составь итоговое письмо строго по структуре.  
— Текст должен быть без пояснений, без маркировки, только готовое письмо.  
— Не добавляй Markdown или комментарии.  
— Письмо должно выглядеть как живое деловое сообщение от рекрутера Omega Solutions кандидату.  
— Обязательно включи в письмо реальные детали вакансии (позиция, формат, стек, задачи).  
— Сохрани фирменный стиль: лаконично, чётко, доброжелательно.

Пример письма:
Пример письма уточнения
Здравствуйте, Максим Александрович!

Спасибо за ваше резюме.
Мы рассматриваем вас на позицию Разработчик-эксперт BPMSoft (<a href="{link}">🆔{vac_id}</a>) в рамках долгосрочного проекта по замещению CRM B2C.

📌 Кратко о вакансии:
— Разработка программных модулей BPMSoft по техническим требованиям;
— Участие в обсуждении архитектуры и требований;
— Интеграции с внешними системами;
— Формат — удалённая полная занятость, поквартальная оплата.

Ваш опыт по BPMSoft, C#, Ext JS и Angular полностью соответствует требованиям вакансии.
Чтобы завершить сверку, пожалуйста, уточните:
— используете ли вы в работе Kafka или аналогичный брокер сообщений?
— работали ли вы с Swagger (OAS) и Postman для тестирования REST API?
— применяете ли вы GitLab в практической разработке?

Также просим подтвердить:
— срок готовности выйти на проект;
— формат оформления (ИП, самозанятый или штат).

«Если у вас есть опыт по выше перечисленным пунктам, пожалуйста, обновите резюме.»

С уважением,
{user_name}

"""

    model = genai.GenerativeModel('gemini-2.5-pro')
    generation_config = genai.types.GenerationConfig(temperature=0.1)

    response = await model.generate_content_async(prompt, generation_config=generation_config)
    return response.text.strip()

  except Exception as e:
    print(f"🔥 Ошибка при формировании письма кандидату: {e}")
    return False


async def generate_mail_for_candidate_otkaz(json_data: dict, user_name: str):
  try:
    vacancy = json_data.get('vacancy', {})
    candidate = json_data.get('candidate', {})

    must_have_candidate = json_data.get('compliance_check', {}).get('must_have', [])
    strong_points = []
    for must_have in must_have_candidate:
      if must_have['status'] == 'Да':
        strong_points.append(must_have['requirement'])

    prompt = f"""
Ты — ассистент IT-рекрутера компании Omega Solutions.  
Ты должен составить письмо кандидату с позитивным отказом.

---

📌 **Требования к письму:**
— Пиши строго в деловом, доброжелательном стиле Omega Solutions.  
— Без Markdown, кавычек, комментариев и форматирования.  
— Структура письма должна быть чистой, логичной и вежливой.  
— Не упоминай деньги, ставки, оплату.  
— Используй имя и отчество, если есть в JSON; если нет — имя и фамилию.  

---

📩 **Структура письма:**

1️⃣ **Приветствие:**  
Здравствуйте, {candidate.get('full_name', 'коллега')}!

2️⃣ **Благодарность:**  
Благодарим вас за резюме и интерес к вакансии {vacancy.get('position_name')} (🆔 {vacancy.get('position_id', '')}).  
Было приятно познакомиться с вашим профессиональным опытом.

3️⃣ **Информация об отказе:**  
К сожалению, по итогам рассмотрения профиля мы не можем предложить участие именно в этой вакансии.  
Решение связано с требованиями проекта, а не с уровнем ваших компетенций.

4️⃣ **Акцент на сильных сторонах:**  
Отметьте 2–3 сильные стороны кандидата на основе {strong_points}.  
Пример:  
«Отдельно отмечаем ваш опыт в разработке микросервисов, уверенное владение Kubernetes и участие в архитектурных решениях.»

5️⃣ **Позитивное завершение:**  
Добавь, что компания Omega Solutions сотрудничает с множеством заказчиков и проектов,  
поэтому мы обязательно предложим кандидату другие подходящие вакансии в будущем.  
Напиши в живом стиле:  
«Мы сохраняем ваше резюме в нашей базе и обязательно свяжемся,  
как только появится проект, соответствующий вашему профилю.»

6️⃣ **Подпись:**  
С уважением,  
{user_name}  

---

✍️ **Инструкция для модели:**
— Составь письмо строго по указанной структуре.  
— Не добавляй Markdown, звёздочки, комментарии.  
— Не включай перечисления требований или задач вакансии.  
— Текст должен быть лаконичным, позитивным и вежливым, с акцентом на уважение к кандидату.  
— В конце — только подпись, без лишних слов.

Пример письма:
Здравствуйте, Виктор Сергеевич!

Благодарим вас за предоставленное резюме и интерес к нашим проектам.
Мы внимательно рассмотрели ваш опыт в рамках позиции Архитектор Senior (🆔AR-10032).

По итогам анализа было принято решение не продвигать вашу кандидатуру на данный проект,
так как требовался более выраженный опыт в области архитектурного моделирования (Camunda, C4 Model)
и работы в логистических доменах.

При этом ваш профессиональный бэкграунд — сильный опыт в .NET, Kafka, DevOps и микросервисной архитектуре —
высоко оценивается, и мы уверены, что он будет востребован в других проектах Omega Solutions.

Мы обязательно свяжемся с вами, когда появятся новые вакансии, где ваш опыт будет максимально релевантен.

С уважением,
{user_name}

"""

    model = genai.GenerativeModel('gemini-2.5-pro')
    generation_config = genai.types.GenerationConfig(temperature=0.1)

    response = await model.generate_content_async(prompt, generation_config=generation_config)
    return response.text.strip()

  except Exception as e:
    print(f"🔥 Ошибка при формировании письма кандидату (отказ): {e}")
    return False


async def generate_cover_letter_for_client(json_data: dict, additional_notes: str = ""):
  try:
    vacancy = json_data.get('vacancy', {}) or {}
    candidate = json_data.get('candidate', {}) or {}
    compliance = json_data.get('compliance_check', {}) or {}

    must_have = compliance.get('must_have', []) or []
    nice_to_have = compliance.get('nice_to_have', []) or []

    manager_nick = vacancy.get('manager_telegram_nickname', 'Менеджер')
    full_name = candidate.get('full_name', 'Кандидат')
    position_name = vacancy.get('position_name', 'позиция')
    position_id = vacancy.get('position_id', '')
    grade = candidate.get('grade_and_position', 'грейд уточняется')
    location = (candidate.get('location') or {}).get('city', 'локация уточняется')
    citizenship = (candidate.get('location') or {}).get('citizenship', None)
    stack = ", ".join((candidate.get('tech_stack') or [])[:8]) or 'технологический стек уточняется'
    full_experience = candidate.get('full_experience', 'опыт работы уточняется')

    summary = json_data.get('summary', {}) or {}
    salary = summary.get('salary_expectations', None)
    availability = summary.get('availability', 'ASAP')

    salary_line = f"Ставка: {salary}" if salary and str(salary).strip().lower() != "нужно уточнить" else None
    citizenship_line = f"Гражданство: {citizenship}" if citizenship else None

    # Фильтруем только подтверждённые требования (Да)
    def only_yes(lst):
      out = []
      for x in lst:
        if (x or {}).get('status') == 'Да':
          out.append({
            "requirement": (x or {}).get('requirement', '').strip(),
            "evidence": ((x or {}).get('evidence') or (x or {}).get('notes') or '').strip()
          })
      return out

    must_yes = only_yes(must_have)
    nice_yes = only_yes(nice_to_have)
   


    # Доп.заметки можно также прокинуть через json_data["additional_notes"], если не передали параметром
    if not additional_notes:
      additional_notes = (json_data.get("additional_notes") or "").strip()

    # Жёсткий шаблон письма — с вшитой логикой красивого рендера «Дополнительно»
    prompt = f"""
Ты — ассистент IT-рекрутера. Сформируй готовое сопроводительное письмо клиенту СТРОГО по шаблону ниже.
Выводи ТОЛЬКО ЧИСТЫЙ ПЛЕЙН-ТЕКСТ (без Markdown, без кавычек, без маркеров списков, без нумерации).
Сохраняй точные заголовки блоков и порядок строк. Не добавляй лишних строк и разделителей.

ВАЖНО:
В разделе «Требования» НЕ включай формальные поля анкеты: ФИО, Дата рождения, Образование, Грейд, Ставка, Электронная почта/Email.
Показывай только реальные требования вакансии, подтверждённые у кандидата (статус Да).

Правила рендера раздела «Дополнительно подтверждённые требования»:
— На вход подаётся сырой текст (может начинаться с «Дополнительно» или сразу с пунктов), вот он в тройных скобках:
<<<{additional_notes}>>>
— Если после удаления пустых строк и очистки ничего не остаётся, раздел «Дополнительно подтверждённые требования» НЕ выводить вообще.
— Очистка каждой строки:
   1) Обрезать пробелы по краям.
   2) Удалить ТОЛЬКО ведущие буллеты/тире: «—», «-», «•», «*» и последующий пробел.
   3) Схлопнуть двойные пробелы.
   4) Сохранить внутренний текст без изменений, включая «— ✅», «— ⚠️» и т.п.
— Формат раздела при наличии хоть одной строки:
   Дополнительно:
   <первая строка>
   <вторая строка>
   ...
— Между «Дополнительные подтверждённые требования:» и «Итог:» вставлять этот раздел, если он не пуст.
— Не добавляй пустых строк до/после «Дополнительно:».

ШАБЛОН ВЫВОДА (строго следуй форматированию и переносам строк):

Представляем кандидата {full_name} на позицию {position_name} {'(' + grade + ')' if grade else ''} по запросу 🆔{position_id}.

Краткая информация о кандидате:
Локация: {location}
{citizenship_line or ''}
Грейд: {grade}
{salary_line or ''}
Готов к старту: {availability}
Опыт: {full_experience}
Стек: {stack}

Соответствие требованиям:
Выведи ТОЛЬКО подтверждённые требования (статус Да).
Перед списком выведи отдельной строкой заголовок: Требования:
Далее выводи каждый пункт одной строкой в формате:
<формулировка требования> — ✅ <очень краткое пояснение, если есть>
Не пиши слово «Требование» перед пунктами.
Не используй маркеры и нумерацию.

Обязательные подтверждённые требования:
{must_yes}

Дополнительные подтверждённые требования:
{nice_yes}

[Если раздел «Дополнительно подтверждённые требования» после очистки НЕ пуст — выведи его тут, строго в формате, описанном выше. Если пуст — пропусти этот блок.]

Итог:
(Одна-две связные строки. Кратко резюмируй соответствие кандидата позиции и отметь релевантный опыт/домен, готовность к старту и сильные стороны. Укажи позицию и грейд.)

Завершающая строка:
📎 Резюме кандидата прилагается (формат White Label, без сокращений, на русском языке, с акцентами на соответствие требованиям вакансии).
С уважением,
{manager_nick}

ВАЖНЫЕ ПРАВИЛА:
— В блоке "Соответствие требованиям" выводи ТОЛЬКО те требования, где статус Да. Не упоминай и не намекай на остальные.
— Для подтверждённых требований используй маркер ✅.
— Не используй списки и Markdown. Каждый пункт выводи строго в формате одной строки.
— Если пояснения нет — сразу после ✅ ничего не добавляй.
— Если раздел «Дополнительно подтверждённые требования» пуст — не выводи его вообще.
"""

    genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
    model = genai.GenerativeModel("gemini-2.5-flash")
    generation_config = genai.types.GenerationConfig(temperature=0.1)

    response = model.generate_content(prompt, generation_config=generation_config)
    return (response.text or "").strip()

  except Exception as e:
    print(f"🔥 Ошибка при формировании письма клиенту: {e}")
    return False

