# OmegaVacancyBot — Структура проекта и описание функций/хендлеров

Дата генерации: 16.10.2025

============================================================
1) Общий обзор
============================================================
- Основная цель проекта: сбор и публикация вакансий (через Telethon и GPT/Gemini), обработка резюме кандидатов, автоматизация коммуникации (письма/сообщения).
- Стек: aiogram (Telegram Bot API), Telethon (клиент Telegram), SQLAlchemy (SQLite), Google Sheets (gspread), Google Gemini API, обработка документов (docx, pdf, rtf, txt), SMTP/IMAP для почты.
- Главная точка входа: `main.py`. Здесь создаётся `Bot`, `Dispatcher`, подключаются роутеры и регистрируются фоновое слежение Telethon и периодические задачи.

============================================================
2) Потоки и порядок работы
============================================================
- Запуск (`main.py`):
  - Инициализация БД (`init_db()`), старт Telethon-клиента, регистрация слушателей новых сообщений/редактирований, запуск фоновых задач:
    - `monitor_and_cleanup()` — мониторинг и деактивация/удаление устаревших/стопнутых вакансий.
    - `check_and_delete_duplicates()` — проверка дубликатов по ID в целевом канале.
    - `check_old_messages_and_mark()` — чистка старых сообщений в канале.
    - `periodic_cleanup_task()` — автоочистка временных таблиц резюме.
    - `update_currency_sheet()` — обновление курсов валют в Google Sheets.
  - Запуск поллинга aiogram-бота.

- При добавлении вакансий:
  - Автоматически: Telethon слушает сообщения по топикам-источникам, фильтрует и обрабатывает текст через Gemini (`process_vacancy_with_gemini` → форматирование `format_vacancy_gemini`), пересылает в целевой канал/топик, сохраняет маппинг `MessageMapping`, отправляет в группу.
  - Вручную: через бота (`/start` без payload → меню → "Добавить вакансию вручную"), пользователь отправляет текст → фильтрация/нормализация через Gemini → выбор целевого топика → публикация.

- При загрузке резюме на вакансию:
  - Пользователь открывает ссылку на бота из вакансии (start=messageId_vacId) → бот показывает вакансию и просит резюме → пользователь кидает файлы → бот аккумулирует загрузки и через 2 сек предлагает «добавить ещё».
  - По кнопке «Нет»: резюме пачкой отправляются на сверку `sverka_vac_and_resume_json` → бот формирует списки «Финалисты», «Требуют уточнений», «Отказы», сохраняет записи в БД и показывает карточки с кнопками дальнейших действий.
  - Генерация писем кандидату/клиенту и отправка по выбранному каналу связи.

============================================================
3) Файлы и их содержимое
============================================================

------------------------------------------------------------
3.1 `main.py`
------------------------------------------------------------
- Переменные окружения: `BOT_TOKEN`, `PHONE_NUMBER`, `GROUP_ID`, `ADMIN_ID`.
- Создание `Bot`, `Dispatcher`, подключение роутеров: `bot_router` (из `aiogram_bot.py`), `pr_router` (из `privyazka_messangers.py`).
- `main()`:
  - Старт `telethon_client` и регистрация слушателей: `register_topic_listener(...)`, `register_simple_edit_listener(...)`.
  - Фоновые задачи: `monitor_and_cleanup`, `check_and_delete_duplicates`, `check_old_messages_and_mark`, `periodic_cleanup_task`, `update_currency_sheet`.
  - `dp.start_polling(bot)` — запуск бота.

------------------------------------------------------------
3.2 `aiogram_bot.py` — aiogram-бот, FSM, пользовательские сценарии
------------------------------------------------------------
- Глобальные:
  - `bot_router = Router()` — основной роутер бота.
  - Состояния FSM: `AddChannel`, `ScanHand`, `ScanVacRekr`, `WaitForNewResume`.
  - `TOPIC_MAP` — соответствие (src_chat, src_topic) → (dst_chat, dst_topic) для публикации.
  - Константы и утилиты: `SAVE_DIR`, `escape_md`, словари буферов загрузок.

- Хендлеры команд/сообщений:
  - `@bot_router.message(CommandStart()) -> cmd_start(message, command, state)`
    - Сброс состояния, показ меню для админов, либо, если payload `start=messageId_vacId`, показывает вакансию по ссылке и переводит в состояние `ScanVacRekr.waiting_for_vac` — ожидание загрузки резюме.

  - Загрузка резюме по вакансии:
    - `@bot_router.message(F.document, ScanVacRekr.waiting_for_vac) -> scan_vac_rekr` → вызывает `save_document(...)`.
    - `save_document(message, state, bot)` — сохраняет файл в `downloads/<user_id>/`, аккумулирует количество, через 2 сек выдаёт итого-сообщение и клавиатуру `scan_vac_rekr_yn_kb()` («Да/Нет»), через 10 сек — сброс счётчика.
    - `@bot_router.callback_query(F.data == "yes_vac_rekr") -> scan_vac_rekr_y` — продолжить загрузку.
    - `@bot_router.callback_query(F.data == "no_vac_rekr") -> scan_vac_rekr_n` — запускает обработку всех загруженных файлов:
      - Для каждого файла `process_file_and_gpt(...)` → `sverka_vac_and_resume_json` → формирует три списка: финалисты/уточнение/отказ.
      - По каждому кандидату отправляет карточку и сохраняет результат в БД: `add_final_resume` / `add_utochnenie_resume` / `add_otkonechenie_resume`.
      - В конце — кнопка `add_another_resume_kb()`.

  - Вывод причин отказа:
    - `@bot_router.callback_query(F.data == "utochnit_prichinu") -> utochnit_prichinu_bot`
      - Достаёт из БД по `message_id` текст отказа и подменяет сообщение на подробности.

  - Генерация письма кандидату:
    - `@bot_router.callback_query(F.data.startswith("generate_mail:")) -> generate_mail_bot`
      - По типу вердикта (`PP/CP/NP`) берёт соответствующую запись из БД, формирует письмо: `create_mails(...)`.
      - Для «Полностью подходит» добавляет клавиатуру `send_mail_or_generate_client_mail_kb()` (отправить кандидату/сгенерировать письмо клиенту), иначе — `send_mail_to_candidate_kb(verdict)`.

  - Генерация письма клиенту:
    - `@bot_router.callback_query(F.data == "generate_klient_mail") -> generate_klient_mail_bot`
      - Берёт данные финалиста из БД → `generate_cover_letter_for_client(...)` → отправляет в канал клиента `CLIENT_CHANNEL` и показывает текст в чате с кнопкой возврата.

  - Возврат к письму кандидату:
    - `@bot_router.callback_query(F.data == "back_to_mail_kand") -> back_to_mail_kand_bot` — возвращает исходное письмо кандидату с клавиатурой отправки.

  - Просмотр подробностей сверки по карточке кандидата:
    - `@bot_router.callback_query(F.data.startswith("get_all_info:")) -> get_all_info_bot` — подменяет карточку на текст сверки и клавиатуру генерации письма соответствующего типа.

  - Отправка письма кандидату:
    - `@bot_router.callback_query(F.data.startswith("send_mail_to_candidate")) -> send_mail_to_candidate_bot`
      - Получает из БД JSON кандидата, показывает клавиатуру контактов `create_contacts_kb(contacts, verdict)`.
    - `@bot_router.callback_query(F.data.startswith("con:")) -> send_mail_to_candidate_bot`
      - В зависимости от источника:
        - `con:t:<@username>:<verdict>` → отправка в Telegram через `send_message_by_username` (Telethon).
        - `con:e:<email>:<verdict>` → отправка письма через `send_email_gmail(...)`.
        - `con:p:<phone>:<verdict>` → отправка контакта в чат.

  - Прочее:
    - `@bot_router.callback_query(F.data == "back_to_menu") -> back_to_menu`
    - `@bot_router.callback_query(F.data == 'scan_redlab')` / `'scan_redlab_day'` / `'scan_redlab_21'` → запуск `forward_messages_from_topics(...)` c разными периодами.
    - Ручная проверка вакансии: `@bot_router.callback_query(F.data == 'scan_hand') -> scan_hand` → перевод в `ScanHand.waiting_for_hand`.
      - `@bot_router.message(ScanHand.waiting_for_hand) -> scan_hand_message` — фильтрация/обработка через Gemini, расчёт блоков зарплаты и форматирование → предложения выбрать топик.
      - `@bot_router.callback_query(ScanHand.waiting_for_topic, F.data.startswith("topic:")) -> scan_hand_topic` — публикация в выбранный топик, отправка в группу и сброс состояния.
    - Отправка номера телефона и кнопки Viber: `@bot_router.message(F.text == "/phone") -> send_phone`.
    - Добавление ещё резюме после обработки: `@bot_router.callback_query(F.data == 'add_another_resume') -> add_another_resume_bot` и `@bot_router.message(F.document, WaitForNewResume.waiting_for_new_resume) -> new_resume_after_scan`.
    - Запрет загрузки вне контекста вакансии: `@bot_router.message(F.document) -> document_without_state`.

- Вспомогательные функции внутри:
  - `escape_md(text)`, `save_document(...)` и вспомогательные буферы/таймеры для аккумулирования загрузок.

------------------------------------------------------------
3.3 `kb.py` — генераторы клавиатур
------------------------------------------------------------
- Главное меню: `main_kb()` — кнопки для «сканирования Redlab» и «добавить вакансию вручную».
- Клавиатуры управления сущностями: `channels_kb()`, `channel_kb(id)`, `slova_kb()`, `slovo_kb(id)`, `filters_kb()`, `filter_kb(id)`, «назад…» клавиатуры.
- Выбор топика для публикации: `send_kb()` (DevOps, Backend, Frontend и т.д.).
- Клавиатуры сценариев резюме: `scan_vac_rekr_yn_kb()`, `utochnit_prichinu_kb()`, `generate_mail_kb(verdict)`, `get_all_info_kb(verdict)`, `send_mail_to_candidate_kb(verdict)`, `send_mail_or_generate_client_mail_kb()`, `create_contacts_kb(contacts, verdict)`, `back_to_mail_kand_kb()`, `viber_kb()`, `add_another_resume_kb()`, `service_kb()`, `next_email_kb()`.

------------------------------------------------------------
3.4 `telethon_bot.py` — чтение и пересылка вакансий из топиков
------------------------------------------------------------
- `telethon_client = TelegramClient('dmitryi', API_ID, API_HASH)` — клиент Telethon.
- `forward_messages_from_topics(telethon_client, TOPIC_MAP, AsyncSessionLocal, bot, days=14)`
  - Находит сообщения по `src_topic_id`, фильтрует (короткие проекты, зачёркнутые, стоп-слова), обрабатывает через Gemini: `process_vacancy_with_gemini` → формирует зарплатные блоки (при необходимости — с расчётом из Google Sheets `search_and_extract_values`) → `format_vacancy_gemini` → публикует в целевой канал/топик ссылкой на бота → отправляет в группу `send_mess_to_group` → сохраняет маппинг `add_message_mapping`.
- `register_topic_listener(...)` — слушатель новых сообщений в отслеживаемых топиках, логика аналогична `forward_messages_from_topics`, но реагирует онлайн.
- `send_message_by_username(username, text)` — отправка личного сообщения пользователю.

------------------------------------------------------------
3.5 `telethon_monitor.py` — мониторинг статуса вакансий и чистка
------------------------------------------------------------
- Маркеры зачёркивания: `has_strikethrough(message)`, `has_strikethrough_id(message, vacancy_id)`.
- `monitor_and_cleanup(telethon_client, AsyncSessionLocal, bot)` — периодически проверяет исходные сообщения по `MessageMapping`:
  - Если текст зачёркнут или содержит «стоп», либо истёк дедлайн — помечает соответствующее сообщение в целевом канале как неактивное (удаляет и публикует «вакансия неактивна»), удаляет маппинг.
- `mark_inactive_and_schedule_delete(client, mapping, vacancy_id, bot)` и `mark_as_deleted(client, msg_id, chat_id, vacancy_id, name_vac, bot)` — переопубликация «неактивно», ожидание 24 часа, удаление.
- `check_and_delete_duplicates(teleton_client, channel_id, bot, topic_map)` — удаляет дубликаты ID в целевом канале.
- `check_old_messages_and_mark(teleton_client, channel_id, bot)` — чистка сообщений старше 14 дней.
- `register_simple_edit_listener(client, channel, bot)` + `on_edit(...)` — реакция на редактирование исходных сообщений: зачёркнутый ID/«стоп» → пометка в целевом канале и удаление.

------------------------------------------------------------
3.6 `scan_documents.py` — обработка резюме и генерация результатов
------------------------------------------------------------
- Парсинг файлов: `process_pdf`, `process_docx`, `process_doc`, `process_rtf`, `process_txt`.
- `process_file_and_gpt(path, bot, user_id, vac_text, file_name)` — извлекает текст и отправляет на сверку `background_sverka(...)`.
- `background_sverka(resume_text, vacancy_text, bot, user_id, file_name)` — вызывает `sverka_vac_and_resume_json`, красиво форматирует отчёт `display_analysis`, чистит JSON `clean_json`, возвращает вердикт/имя/текст сверки.
- Отчёт и утилиты: `clean_json`, `display_analysis`, `create_finalists_table(finalists)`, `create_mails(finalist, user_name)` — роутинг к `generate_mail_for_candidate_*`/`generate_cover_letter_for_client`.

------------------------------------------------------------
3.7 `gpt_gimini.py` — интеграция с Google Gemini
------------------------------------------------------------
- `process_vacancy_with_gemini(text)` — фильтрация вакансий и извлечение полей (ID, ставка, дедлайн, заголовок, локация, флаги условий и др.). При отсеивании возвращает reason/None.
- `format_vacancy_gemini(text, vacancy_id, date=None)` — форматирование вакансии для публикации согласно шаблону.
- `generate_hashtags_gemini(vacancy_text)` — генерация хэштегов.
- `sverka_vac_and_resume_json(vacancy_text, resume_text, file_name)` — сверка резюме с вакансией, возвращает строгий JSON с оценкой must/nice-to-have, контактов, зарплаты, вердикта.
- Также используются (через импорты в проекте):
  - `generate_mail_for_candidate_finalist(finalist, user_name)`
  - `generate_mail_for_candidate_utochnenie(finalist, user_name)`
  - `generate_mail_for_candidate_otkaz(finalist, user_name)`
  - `generate_cover_letter_for_client(candidate_json)`

------------------------------------------------------------
3.8 `googlesheets.py` — работа с Google Sheets
------------------------------------------------------------
- Авторизация `gspread` по `creds.json`.
- `find_rate_in_sheet_gspread(search_value_usd)` — поиск ставки.
- `search_and_extract_values(search_column, search_value, extract_columns, worksheet_name, sheet_url)` — извлечение значений (в т.ч. округление значений IP/самозанятый до 1000).
- `fill_column_with_sequential_numbers(column_letter, worksheet_name, start_row, value, sheet_id)` — массовая запись колонки.
- `update_currency_sheet(bot, ADMIN_ID)` — раз в сутки парсит курсы с ЦБ РФ (через `parse_cb_rf`) и записывает в 2 листа.

------------------------------------------------------------
3.9 `funcs.py` — утилиты проекта
------------------------------------------------------------
- Фильтр вакансий: `check_project_duration(text)` — отсекает проекты < 3 мес по множеству паттернов.
- Текстовые утилиты: `remove_vacancy_id(text)`, `_clean_markup`, `extract_vacancy_id(text)` — извлечение/очистка ID, `get_vacancy_title(text)` — заголовок по отметке 🥇.
- Отправка в группу: `send_mess_to_group(group_id, message, vacancy_id, bot)` — добавляет сквозной счётчик, пометку и хэштеги (`generate_hashtags_gemini`).
- Дата/время сообщений: `get_message_datetime(msg, tz)`.
- Форматирование JSON кандидата: `format_candidate_json_str(raw_str)`.
- Парсер курсов ЦБ РФ: `parse_cb_rf()`.

------------------------------------------------------------
3.10 `db.py` — модели и операции БД (SQLite, SQLAlchemy Async)
------------------------------------------------------------
- Модели:
  - `Channel`, `Filter`, `Slova` — справочники.
  - `MessageMapping` — соответствие исходного и опубликованного сообщений, с дедлайном.
  - `LastSequenceNumber` — счётчик для сквозной нумерации публикаций.
  - `OtkonechenieResume`, `UtochnenieResume`, `FinalResume` — временные таблицы карточек кандидатов с `message_id`, текстом и JSON.
  - `PrivyazanieMessangers` — привязка почт к tg-username.
  - `SaveResumes` — сохранённые сырые резюме кандидатов.
- Инициализация: `init_db()`.
- CRUD:
  - Каналы/фильтры/слова: `add_channel/remove_channel/get_all_channels`, `add_filter/get_all_filters/remove_filter`, `add_slovo/get_all_slova/remove_slovo`.
  - Маппинги сообщений: `add_message_mapping/get_all_message_mappings/remove_message_mapping`.
  - Последовательность: `get_next_sequence_number`.
  - Резюме: `add_final_resume/get_final_resume/remove_old_final_resumes`, `add_utochnenie_resume/get_utochnenie_resume/remove_old_utochnenie_resumes`, `add_otkonechenie_resume/get_otkolenie_resume/remove_old_otkonechenie_resumes`, периодика `periodic_cleanup_task`.
  - Сохранённые резюме: `add_save_resume/get_save_resume/remove_save_resume`.
  - Привязка email: `add_email(user_name_tg, user_email, password)`.

------------------------------------------------------------
3.11 `send_email.py` — SMTP/IMAP утилиты
------------------------------------------------------------
- `sanitize_header(value)` — очистка заголовков.
- `send_email_gmail(sender_email, app_password, recipient_email, subject, body, html=False, attachments=None)` — отправка почты через Gmail (aiosmtplib).
- `fetch_last_emails(imap_user, imap_pass, mailbox='inbox', limit=10)` — чтение последних писем IMAP (Gmail).

------------------------------------------------------------
3.12 `privyazka_messangers.py` — привязка аккаунтов к боту
------------------------------------------------------------
- Роутер: `pr_router = Router()`.
- FSM: `PrivyazkaEmail`, `PrivyazkaTelegram`.
- Хендлеры:
  - `@pr_router.message(Command("add_account")) -> add_account` — выбор сервиса (gmail/telegram).
  - `@pr_router.callback_query(F.data.in_(["gmail","telegram"])) -> add_gmail_account` — инструкция для Gmail и кнопка «Далее».
  - `@pr_router.callback_query(F.data == "next_email") -> next_email` — запрос email и перевод в состояние `PrivyazkaEmail.waiting_for_email`.
  - `@pr_router.message(PrivyazkaEmail.waiting_for_email) -> add_email_account` — запрос пароля приложений.
  - `@pr_router.message(PrivyazkaEmail.waiting_for_password) -> add_email_password` — тестовая отправка письма, запись в БД `add_email(...)`.

------------------------------------------------------------
3.13 `teleton_client.py` — вспомогательные функции Telethon (конверсия, HTML, склонения)
------------------------------------------------------------
- Подписка/получение канала: `get_channel_info(channel_id_or_name, client, phone_number)`.
- Выход из канала: `leave_channel_listening(channel_id, client, phone_number)` (фактически не покидает, но проверяет доступность).
- Генерация падежных форм: `generate_all_case_forms(phrase)`.
- Конвертация `message` → безопасный HTML с учётом entities: `message_to_html_safe(message)`.

============================================================
4) Перечень всех aiogram-хендлеров и порядок
============================================================
- `@bot_router.message(CommandStart())` → старт / вход по ссылке вакансии.
- `@bot_router.callback_query('scan_redlab'/'scan_redlab_day'/'scan_redlab_21')` → сканирование и публикация вакансий по топикам.
- `@bot_router.callback_query('scan_hand')` → ввод произвольной вакансии → `@bot_router.message(ScanHand.waiting_for_hand)` → `@bot_router.callback_query(ScanHand.waiting_for_topic, 'topic:*')`.
- `@bot_router.message(F.document, ScanVacRekr.waiting_for_vac)` → загрузка резюме → `yes_vac_rekr`/`no_vac_rekr` → формирование списков кандидатов.
- Карточки кандидатов:
  - `get_all_info:*` → показать сверку;
  - `generate_mail:*` → создать письмо кандидату;
  - `generate_klient_mail` → письмо клиенту;
  - `back_to_mail_kand` → вернуться к письму кандидату;
  - `send_mail_to_candidate:*` → выбор канала связи;
  - `con:*` → отправка (Telegram/Email/Phone).
- Прочее: `back_to_menu`, `/phone`, `add_another_resume` и последующая загрузка, защита от загрузки без контекста вакансии.

============================================================
5) Важные зависимости окружения и файлы
============================================================
- `.env`: BOT_TOKEN, API_ID, API_HASH, PHONE_NUMBER, GROUP_ID, ADMIN_ID, CLIENT_CHANNEL, GEMINI_API_KEY и др.
- `requirements.txt`: полный список библиотек (aiogram, Telethon, SQLAlchemy, google-generativeai, gspread, docx/pdf/rtf обработчики и пр.).
- `creds.json`: сервисный аккаунт Google для Sheets.
- `channels.db`: SQLite база данных.
- Папки: `downloads/` — временное хранилище загруженных резюме.

============================================================
6) Примечания по устойчивости и ошибкам
============================================================
- При ошибках Gemini/Google Sheets/SMTP/Telethon — предусмотрены try/except с уведомлением админа (в ряде функций) и безопасными возвратами.
- Очистка временных таблиц резюме каждые 12 часов (`periodic_cleanup_task`).
- Дубликаты и «стоп»-сообщения удаляются автоматически, зачёркнутые ID отслеживаются через entities.

Конец файла.
